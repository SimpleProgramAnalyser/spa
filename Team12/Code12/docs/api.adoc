= API Documentation
:toc:
This document provides the relevant techinical APIs exposed by each different component.

== Frontend
=== Parser API
*Overview*: The Parser API describes methods available to the parser of the Simple Program
Analyser (SPA). The main method, parseSimple, is the main entry point to the program,
where a SIMPLE program string is input for analysis.

* <<parseSimple>>
* <<parseExpression>>

'''

[#parseSimple]
`*VOID* parseSimple(*STRING* rawProgram) throws *SYNTAX_ERROR*;`

*Description*: Takes in a SIMPLE program string so the PKB can be populated with entries.
If the program string is not in valid SIMPLE syntax, or contains semantic errors,
an ERROR will be thrown. +

'''

[#parseExpression]
`*EXPRESSION* parseExpression(*STRING_LIST* lexedExpression);`

**Description**: Takes in a lexed SIMPLE expression, and returns an Abstract Syntax Tree (AST)
node that represents the expression. This method may be used to pattern-match queries.

=== Design Extractor API
*Overview*: The Design Extractor API describes methods available to the Design
Extractor of the Simple Program Analyser (SPA). In the Design Extractor, program
design entity relationships are identified and stored in the PKB. The main method,
extractDesign, provides the inputs required by the Design Extractor to determine
program design entity relationships, namely an Abstract Syntax Tree (AST) of a
SIMPLE program.

* <<extractDesign>>

'''

[#extractDesign]
`*VOID* extractDesign(*PROGRAM_NODE* rootNode) throws *SEMANTIC_ERROR*;`

*Description*: Takes in a SIMPLE AST and walks the tree, identifying the presence of
important relationships between program design entities. If the program contains
semantic errors, a SEMANTIC_ERROR will be thrown. +

=== Abstract Syntax Tree (AST) API
*Overview*: The AST API describes the methods available to construct an Abstract Syntax Tree
in the Simple Program Analyser (SPA).

==== Nodes API
*Overview*: The Nodes API describes the methods available to create Node representations
in the Simple Program Analyser (SPA).

* <<createAssignNode>>
* <<createCallNode>>
* <<createIfNode>>
* <<createPrintNode>>
* <<createProcedureNode>>
* <<createProgramNode>>
* <<createReadNode>>
* <<createStmtlstNode>>
* <<createWhileNode>>

'''

[#createAssignNode]
`*ASSIGNMENT_STATEMENT_NODE* createAssignNode(*STATEMENT_NUMBER* sn, *VARIABLE* var, *EXPRESSION* expr);`

*Description*: Creates and returns an *ASSIGNMENT_STATEMENT_NODE* with `var` and `expr` as the children,
and `sn` as its statement number.

'''

[#createCallNode]
`*CALL_STATEMENT_NODE* createCallNode(*STATEMENT_NUMBER* sn, *NAME* procName);`

*Description*: Creates and returns a *CALL_STATEMENT_NODE* with `procName` as the child,
and `sn` as its statement number.

'''

[#createIfNode]
`*IF_STATEMENT_NODE* createIfNode(*STATEMENT_NUMBER* sn, *CONDITIONAL_EXPRESSION* predicate,
*STMTLST_NODE* leftStatementList, *STMTLST_NODE* rightStatementList);`

*Description*: Creates and returns an *IF_STATEMENT_NODE* with the condition `predicate`,
`leftStatementList` and `rightStatementList` as the children,
and `sn` as its statement number.

'''

[#createPrintNode]
`*PRINT_STATEMENT_NODE* createPrintNode(*STATEMENT_NUMBER* sn, *VARIABLE* var);`

*Description*: Creates and returns a *PRINT_STATEMENT_NODE* with `var` as the child,
and `sn` as its statement number.

'''

[#createProcedureNode]
`*PROCEDURE_NODE* createProcedureNode(*NAME* procedureName, *STMTLST_NODE* stmtlstNode);`

*Description*: Creates and returns a *PROCEDURE_NODE* with `stmtlstNode` as the child,
and `procedureName` as the name of the procedure.

'''

[#createProgramNode]
`*PROGRAM_NODE* createProgramNode(*NAME* programName, *PROCEDURE_NODE_LIST* procedureNodes,
*STATEMENT_NUMBER* totalStmts);`

*Description*: Creates and returns a *PROGRAM_NODE* with `procedureNodes` as the child in a
*PROCEDURE_NODE_LIST* form, and `programName` as the name of the program. It also stores the
total number of statements `totalStmts`.

'''

[#createReadNode]
`*READ_STATEMENT_NODE* createReadNode(*STATEMENT_NUMBER* sn, *VARIABLE* var);`

*Description*: Creates and returns a *READ_STATEMENT_NODE* with `var` as the child,
and `sn` as its statement number.

'''

[#createStmtlstNode]
`*STMTLST_NODE* createStmtlstNode(*STATEMENT_NODE_LIST* statementNodes);`

*Description*: Creates and returns a *STMTLST_NODE* with `statementNodes` as its children;

'''

[#createWhileNode]
`*WHILE_STATEMENT_NODE* createWhileNode(*STATEMENT_NUMBER* sn, *CONDITIONAL_EXPRESSION* predicate,
*STMTLST_NODE* statementList);`

*Description*: Creates and returns an *WHILE_STATEMENT_NODE* with the condition `predicate`,
`statementList` as its children, and `sn` as its statement number.

==== Expressions API
*Overview*: The Expressions API describes the methods available to create Expression representations
in the Simple Program Analyser (SPA).

* <<createAndExpr>>
* <<createDivExpr>>
* <<createEqExpr>>
* <<createGtExpr>>
* <<createGteExpr>>
* <<createLtExpr>>
* <<createLteExpr>>
* <<createMinusExpr>>
* <<createModExpr>>
* <<createNeqExpr>>
* <<createNotExpr>>
* <<createOrExpr>>
* <<createPlusExpr>>
* <<createRefExpr>>
* <<createTimesExpr>>

[#createAndExpr]
`*AND_EXPRESSION* createAndExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *AND_EXPRESSION* where the truthy value depends on
both `leftExpr` and the `rightExpr`. This corresponds to the "```&&```" operation in SIMPLE.

'''

[#createDivExpr]
`*ARITHMETIC_EXPRESSION* createDivExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is divided
by the `rightExpr`. This corresponds to the "```/```" operation in SIMPLE.

'''

[#createEqExpr]
`*RELATIONAL_EXPRESSION* createEqExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is equal
to the `rightRelFactor`. This corresponds to the "```==```" operation in SIMPLE.

'''

[#createGtExpr]
`*RELATIONAL_EXPRESSION* createGtExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is greater
than the `rightRelFactor`. This corresponds to the "```>```" operation in SIMPLE.

'''

[#createGteExpr]
`*RELATIONAL_EXPRESSION* createGteExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is greater
than or equals to the `rightRelFactor`.  This corresponds to the "```>=```" operation in SIMPLE.

'''

[#createLtExpr]
`*RELATIONAL_EXPRESSION* createLtExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is lesser
than the `rightRelFactor`.  This corresponds to the "```<```" operation in SIMPLE.

'''

[#createLteExpr]
*`RELATIONAL_EXPRESSION* createLteExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is lesser
than or equals to the `rightRelFactor`.  This corresponds to the "```&lt;=```" operation in SIMPLE.

'''

[#createMinusExpr]
`*ARITHMETIC_EXPRESSION* createMinusExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is divided
by the `rightExpr`.  This corresponds to the "```-```" operation in SIMPLE.

'''

[#createModExpr]
`*ARITHMETIC_EXPRESSION* createModExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is mod
by the `rightExpr`. This corresponds to the "```%```" operation in SIMPLE.

'''

[#createNeqExpr]
`*RELATIONAL_EXPRESSION* createNeqExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is not
equal to the `rightRelFactor`. This corresponds to the "```!=```" operation in SIMPLE.

'''

[#createNotExpr]
`*NOT_EXPRESSION* createNotExpr(*CONDITIONAL_EXPRESSION* expr);`

*Description*: Creates and returns an *NOT_EXPRESSION* with the negated value of `expr`.
This corresponds to the "```!```" operation in SIMPLE.

'''

[#createOrExpr]
`*OR_EXPRESSION* createOrExpr(*CONDITIONAL_EXPRESSION* leftExpr, *CONDITIONAL_EXPRESSION* rightExpr);`

*Description*: Creates and returns an *OR_EXPRESSION* where the truthy value depends on
either `leftExpr` or the `rightExpr`. This corresponds to the "```||```" operation in SIMPLE.

'''

[#createPlusExpr]
`*ARITHMETIC_EXPRESSION* createPlusExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is added
to the `rightExpr`. This corresponds to the "```+```" operation in SIMPLE.

'''

[#createRefExpr]
`*REFERENCE_EXPRESSION* createRefExpr(*STRING* variable);`

`*REFERENCE_EXPRESSION* createRefExpr(*INTEGER* constant);`

*Description*: Creates and returns a *REFERENCE_EXPRESSION* based on `variable`
or `constant`. Reference expressions can be either a variable or a constant.
To create a reference expression based on a variable, pass the variable name
as a `STRING`, and to create a reference expression based
on a constant, pass the constant value as an `Integer`.

'''

[#createTimesExpr]
`*ARITHMETIC_EXPRESSION* createTimesExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an  *ARITHMETIC_EXPRESSION* where the `leftExpr` is multiplied
with the `rightExpr`. This corresponds to the "```*```" operation in SIMPLE.

==== AST Helper API
*Overview*: The AST Helper API describes useful methods that are
often used when dealing with an Abstract Syntax Tree.

* <<isContainerStatement>>

[#isContainerStatement]
`*BOOLEAN* isContainerStatement(*STATEMENT_TYPE* stmtType);`

*Description*: Returns true if `stmtType` corresponds to an "if" statement
or a "while" statement in SIMPLE. These statements contain other statements
of their own, hence they are also known as "container statements".

'''


== PKB

=== Statement Table API

*Overview*: The Statement Table API describes the methods available to extract information related to statements.

* <<getAllStatements>>
* <<isStatementInProgram>>
* <<insertIntoStatementTable>>

'''

[#getAllStatements]
`*STATEMENT_LIST* getAllStatements(*DESIGN_ENT_STMT_NAME* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all the statements in the Statement Table.

'''

[#isStatementInProgram]
`*BOOLEAN* isStatementInProgram(*INTEGER* number);`

*Description*: Returns a *BOOLEAN* stating whether statement is in the Statement Table.

'''

[#insertIntoStatementTable]
`*VOID* insertIntoStatementTable(*INTEGER* number, *STATEMENT_TYPE* type);`

*Description*: Inserts a *STATEMENT* `statement` with its corresponding *STATEMENT_TYPE* into the Statement Table.

=== Variable Table API

*Overview*: The Variable Table API describes the methods available to extract information related to variables in the processed SIMPLE program.

* <<getAllVariables>>
* <<isVariableInProgram>>
* <<insertIntoVariableTable>>

'''

[#getAllVariables]
`*VARIABLE_LIST* getAllVariables();`

*Description*: Returns a *VARIABLE_LIST* of all variables stored in the Variable Table.

'''

[#isVariableInProgram]
`*BOOLEAN* isVariableInProgram(*VARIABLE* var);`

*Description*: Returns a *BOOLEAN* stating whether variable is in the Variable Table.

'''

[#insertIntoVariableTable]
`*VOID* insertIntoVariableTable(*VARIABLE* var);`

*Description*: Inserts the *VARIABLE* `var` into Variable Table.

=== Procedure Table API

*Overview*: The Procedure Table API describes the methods available to extract information related to procedures in the processed SIMPLE program.

* <<getAllProcedures>>
* <<isProcedureInProgram>>
* <<insertIntoProcedureTable>>

'''

[#getAllProcedures]
`*PROCEDURE_LIST* getAllProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all procedures stored in the Procedure Table.

'''

[#isProcedureInProgram]
`*BOOLEAN* isProcedureInProgram(*PROCEDURE* proc);`

*Description*: Returns a *BOOLEAN* stating whether procedure is in the Procedure Table.

'''

[#insertIntoProcedureTable]
`*VOID* insertIntoProcedureTable(*PROCEDURE* proc);`

*Description*: Inserts the *PROCEDURE* `proc` into Procedure Table.

=== Constant Table API

*Overview*: The Constant Table API describes the methods available to extract information related to constantedures in the processed SIMPLE program.

* <<getAllConstants>>
* <<isConstantInProgram>>
* <<insertIntoConstantTable>>

'''

[#getAllConstants]
`*CONSTANT_LIST* getAllConstants();`

*Description*: Returns a *CONSTANT_LIST* of all constantedures stored in the Constant Table.

'''

[#isConstantInProgram]
`*BOOLEAN* isConstantInProgram(*CONSTANT* constant);`

*Description*: Returns a *BOOLEAN* stating whether constantedure is in the Constant Table.

'''

[#insertIntoConstantTable]
`*VOID* insertIntoConstantTable(*CONSTANT* constant);`

*Description*: Inserts the *CONSTANT* `constant` into Constant Table.

=== Uses API

*Overview*: The Uses API describes the methods available to extract information related to the Uses relationships in the processed SIMPLE program.

* <<addUsesRelationships>>
* <<checkIfProcedureUses>>
* <<checkIfStatementUses>>
* <<getAllUsesProcedures>>
* <<getAllUsesStatements>>
* <<getAllUsesVariables>>
* <<getUsesProcedures>>
* <<getUsesStatements>>
* <<getUsesVariablesFromStatement>>
* <<getUsesVariablesFromProcedure>>

'''

[#addUsesRelationships]
`*VOID* addUsesRelationships(*INTEGER* stmt, *VARIABLE_LIST* varList);`

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are modified in `stmt`
to the Uses Table.

'''

[#checkIfProcedureUses]
`*PROCEDURE_LIST* checkIfProcedureUses(*STRING* proc, *STRING* var);`

*Description*: Returns the *PROCEDURE* in a *PROCEDURE_LIST* if `proc` uses `var`,
otherwise an empty *PROCEDURE_LIST* is returned.

'''

[#checkIfStatementUses]
`*STATEMENT_LIST* checkIfStatementUses(*INTEGER* stmt, *STRING* var);`

*Description*: Returns the `*STATEMENT*` in a STATEMENT_LIST if `stmt` uses `var`, otherwise
an empty *STATEMENT_LIST* is returned.

'''

[#getAllUsesProcedures]
`*PROCECURE_LIST* getAllUsesProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all PROCEDURE that uses a *VARIABLE*.

'''

[#getAllUsesStatements]
`*STATEMENT_LIST* getAllUsesStatements(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all STATEMENT that uses a *VARIABLE*.

'''

[#getAllUsesVariables]
`*VARIABLE_LIST* getAllUsesVariables();`

Description: Returns a *VARIABLE_LIST* of all variables that are used in the SIMPLE program.

'''

[#getUsesProcedures]
`*PROCEDURE_LIST* getUsesProcedures(*VARIABLE* var);`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that uses a *VARIABLE* `var`.

'''

[#getUsesStatements]
`*STATEMENT_LIST* getUsesStatements(*VARIABLE* var, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`,
that uses *VARIABLE* `var`.

'''

[#getUsesVariablesFromStatement]
`*VARIABLE_LIST* getUsesVariablesFromStatement(*INTEGER* stmt);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that `stmt` uses.

'''

[#getUsesVariablesFromProcedure]
`*VARIABLE_LIST* getUsesVariablesFromProcedure(*PROCEDURE* proc);`

*Description*: Returns a *VARIABLE_LIST* of variables that were used
in `proc`.

=== Modifies API
*Overview*: The Modifies API describes the methods exposed by Modifies Table to insert and
extract information related to the Modifies relationships in the processed SIMPLE program.

* <<addModifiesRelationships>>
* <<checkIfProcedureModifies>>
* <<checkIfStatementModifies>>
* <<getAllModifiesProcedures>>
* <<getAllModifiesStatements>>
* <<getAllModifiesVariables>>
* <<getModifiesProcedures>>
* <<getModifiesStatements>>
* <<getVariablesModifiedInProcedure>>
* <<getVariablesModifiedByStatement>>

'''

[#addModifiesRelationships]
`*VOID* addModifiesRelationships(*INTEGER* stmt, *VARIABLE_LIST* varList);`

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are modified in `stmt`
to the Modifies Table.

'''

[#checkIfProcedureModifies]
`*PROCEDURE_LIST* checkIfProcedureModifies(*STRING* proc, *STRING* var);`

*Description*: Returns the *PROCEDURE* in a *PROCEDURE_LIST* if `proc` modifies `var`,
otherwise an empty *PROCEDURE_LIST* is returned.

'''

[#checkIfStatementModifies]
`*STATEMENT_LIST* checkIfStatementModifies(*INTEGER* stmt, *STRING* var);`

*Description*: Returns the *STATEMENT* in a *STATEMENT_LIST* if `stmt` modifies `var`,
otherwise an empty *STATEMENT_LIST* is returned.

'''

[#getAllModifiesProcedures]
`*PROCEDURE_LIST* getAllModifiesProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that modifies.

'''

[#getAllModifiesStatements]
`*STATEMENT_LIST* getAllModifiesStatements(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* that modifies.

'''

[#getAllModifiesVariables]
`*VARIABLE_LIST* getAllModifiesVariables(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that are modified by
*STATEMENT* of *STATEMENT_TYPE*.

'''

[#getModifiesProcedures]
`*PROCEDURE_LIST* getModifiesProcedures(*VARIABLE* var);`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that modifies *VARIABLE* `var`.

'''

[#getModifiesStatements]
`*STATEMENT_LIST* getModifiesStatements(*VARIABLE* var, *STATEMENT_TYPE* stmtType) ;`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE*, that
modifies *VARIABLE* `var`.

'''

[#getVariablesModifiedInProcedure]
`*VARIABLE_LIST* getVariablesModifiedInProcedure(*PROCEDURE* proc);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that are modified
by *PROCEDURE* `proc`.

'''

[#getVariablesModifiedByStatement]
`*VARIABLE_LIST* getVariablesModifiedByStatement(*INTEGER* stmt);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that are modified by
`stmt`.

=== Parent API
*Overview*: The Parent API describes the methods exposed by Parent Table to insert and
extract information related to the Parent relationships in the processed SIMPLE program.

* <<addParentRelationships>>
* <<addParentRelationshipsStar>>
* <<checkIfParentHolds>>
* <<getAllChildStatements>>
* <<getAllChildStatementsStar>>
* <<getAllChildStatementsTyped>>
* <<getAllChildStatementsTypedStar>>
* <<getAllParentStatements>>
* <<getAllParentStatementsStar>>
* <<getAllParentStatementsTyped>>
* <<getAllParentStatementsTypedStar>>

'''

[#addParentRelationships]
`*VOID* addParentRelationships(*INTEGER* parent, *INTEGER* child);`

*Description*: Adds a Parent relationship between `parent` and `child` into
the Parent Table.

'''

[#addParentRelationshipsStar]
`*VOID* addParentRelationshipsStar(*INTEGER* parent, *INTEGER_LIST* children);`

Description: Adds all the Parent relationship between `parent` and `children` into
the Parent* Table.

'''

[#checkIfParentHolds]
`*STATEMENT_LIST* checkIfParentHolds(*INTEGER* parent, *INTEGER* child);`

*Description*: Returns the *STATEMENT* in a *STATEMENT_LIST* if there is a Parent
relationship between `parent` and `child`, else return an empty *STATEMENT_LIST*.

'''

[#getAllChildStatements]
`*STATEMENT_LIST* getAllChildStatements(*INTEGER* parent, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all child *STATEMENT* of `parent`. Child
*STATEMENT* are of *STATEMENT_TYPE* `stmtType`.

'''

[#getAllChildStatementsStar]
`*STATEMENT_LIST* getAllChildStatementsStar(*INTEGER* parent, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all _transitive_ child *STATEMENT* of `parent`.
Child *STATEMENT* are of *STATEMENT_TYPE* `stmtType`.

'''

[#getAllChildStatementsTyped]
`*STATEMENT_LIST* getAllChildStatementsTyped(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all children that are of *STATEMENT_TYPE*
`stmtTypeOfChild`, with a child of *STATEMENT_TYPE* `stmtTypeOfParent`.

'''

[#getAllChildStatementsTypedStar]
`*STATEMENT_LIST* getAllChildStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all children that are of *STATEMENT_TYPE*
`stmtTypeOfChild`, with a _transitive_ Parent of *STATEMENT_TYPE* `stmtTypeOfParent`.

'''

[#getAllParentStatements]
`*STATEMENT_LIST* getAllParentStatements(*INTEGER* child, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of Parent of *STATEMENT_TYPE* `stmtType`, of `child`.
Returns an empty *STATEMENT_LIST* if said Parent does not exist.

'''

[#getAllParentStatementsStar]
`*STATEMENT_LIST* getAllParentStatementsStar(*INTEGER* child, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all _transitive_ Parent of `child`. Parents
are of STATEMENT_TYPE `stmtType`.

'''

[#getAllParentStatementsTyped]
`*STATEMENT_LIST* getAllParentStatementsTyped(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all Parents that are of *STATEMENT_TYPE*
`stmtTypeOfParent`, with a child of *STATEMENT_TYPE* `stmtTypeOfChild`.

'''

[#getAllParentStatementsTypedStar]
`*STATEMENT_LIST* getAllParentStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all Parents that are of *STATEMENT_TYPE*
`stmtTypeOfParent`, with a _transitive_ child of *STATEMENT_TYPE* `stmtTypeOfChild`.


=== Follows API
*Overview*: The Follows API describes the methods exposed by Follows Table to insert and
extract information related to the Follows relationships in the processed SIMPLE program.

* <<addFollowsRelationships>>
* <<addFollowsRelationshipsStar>>
* <<checkIfFollowsHolds>>
* <<getAllStatementsAfterStar>>
* <<getAllStatementsAfterTyped>>
* <<getAllStatementsAfterTypedStar>>
* <<getAllStatementsBeforeStar>>
* <<getAllStatementsBeforeTyped>>
* <<getAllStatementsBeforeTypedStar>>
* <<getStatementAfter>>
* <<getStatementBefore>>

'''

[#addFollowsRelationships]
`*VOID* addFollowsRelationships(*INTEGER* before, *INTEGER* after);`

*Description*: Adds a *Follows* relationship between `before` and `after` into
the *Follows Table*.

'''

[#addFollowsRelationshipsStar]
`*VOID* addFollowsRelationshipsStar(*INTEGER* before, *INTEGER_LIST* after);`

*Description*: Adds all *STATEMENT* that *Follows* after `before`, as an *INTEGER_LIST*.

'''

[#checkIfFollowsHolds]
`*BOOLEAN* checkIfFollowsHolds(*INTEGER* beforeStatement, *INTEGER* afterStatement);`

*Description*: Returns true if `afterStatement` *Follows* after `beforeStatement`.

'''

[#getAllStatementsAfterStar]
`*STATEMENT_LIST* getAllStatementsAfterStar(*INTEGER* statement, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`,
that _transitively_ *Follows* after `statement`.

'''

[#getAllStatementsAfterTyped]
`*STATEMENT_LIST* getAllStatementsAfterTyped(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* with *STATEMENT_TYPE* `stmtTypeOfAfter`,
that *Follows* after *STATEMENT* of *STATEMENT_TYPE* `stmtTypeOfBefore`.

'''

[#getAllStatementsAfterTypedStar]
`*STATEMENT_LIST* getAllStatementsAfterTypedStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* with *STATEMENT_TYPE* `stmtTypeOfAfter`,
that _transitively_ *Follows* after *STATEMENT* of *STATEMENT_TYPE* `stmtTypeOfBefore`.

'''

[#getAllStatementsBeforeStar]
`*STATEMENT_LIST* getAllStatementsBeforeStar(*INTEGER* statement, *STATEMENT_TYPE* stmtType));`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`,
that _transitively_ *Follows* before `statement`.

'''

[#getAllStatementsBeforeTyped]
`*STATEMENT_LIST* getAllStatementsBeforeTyped(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* with *STATEMENT_TYPE* `stmtTypeOfBefore`,
that *Follows* before *STATEMENT* of *STATEMENT_TYPE* `stmtTypeOfAfter`.

'''

[#getAllStatementsBeforeTypedStar]
`*STATEMENT_LIST* getAllStatementsBeforeTypedStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* with *STATEMENT_TYPE* `stmtTypeOfBefore`,
that _transitively_ *Follows* before *STATEMENT* of *STATEMENT_TYPE* `stmtTypeOfAfter`.

'''

[#getStatementAfter]
`*STATEMENT_LIST* getStatementAfter(*INTEGER* statement, *STATEMENT_TYPE* stmtType);`

*Description*: Returns the *STATEMENT* of *STATEMENT_TYPE* `stmtType` that *Follows* after
`statement`, in a *STATEMENT_LIST*, otherwise an empty *STATEMENT_LIST* is returned.

'''

[#getStatementBefore]
`*STATEMENT_LIST* getStatementBefore(*INTEGER* statement, *STATEMENT_TYPE* stmtType);`

*Description*: Returns the *STATEMENT* of *STATEMENT_TYPE* `stmtType` that *Follows* before
`statement`, in a *STATEMENT_LIST*, otherwise an empty *STATEMENT_LIST* is returned.

== PQL

=== PQLManager API
*Overview*: Handles the business logic for processing and evaluating Processed
Query Language (PQL) queries.

* <<execute>>

'''

[#execute]
`*FORMATTED_QUERY_RESULT* execute(*STRING* query);`

*Description*: Returns a *FORMATTED_QUERY_RESULT* after processing and evaluating a
`query` in *Processed Query Language* (PQL) form.

=== PreProcessor API
*Overview*: Handles the business logic for pre-processing PQL queries, including validating
syntax and semantics.

* <<processQuery>>

'''

[#processQuery]
`*ABSTRACT_QUERY* processQuery(*STRING* query);`

*Description*: Returns an *ABSTRACT_QUERY* after validating and breaking down the `query`.

=== Evaluator API
*Overview*: Evaluates the processed query and obtain a result for it by interacting
with the PKB.

* <<evaluateQuery>>

'''

[#evaluateQuery]
`*RAW_QUERY_RESULT* evaluateQuery(*STRING* query);`

*Description*: Returns a *RAW_QUERY_RESULT* after evaluating the `query` and obtaining information
from the PKB.

=== Projector API
*Overview*: Formats query results into human readable context.

* <<formatResult>>

'''

[#formatResult]
`*FORMATTED_RESULT* formatResult(*RAW_QUERY_RESULT* rawQueryResult);`

*Description*: Returns a *FORMATTED_RESULT* after formatting `rawQueryResult` to
a conforming standard.

== Shared Libraries (for internal use)

=== Lexer API

* <<isWhitespace>>
* <<splitByDelimiter>>
* <<splitByWhitespace>>
* <<splitProgram>>
* <<trimWhitespace>>

'''

[#isWhitespace]
`*BOOLEAN* isWhitespace(*CHAR** c);`

*Desrciption*: Returns true if *CHAR* `c` is a whitespace character,
and vice versa.

'''

[#splitByDelimiter]
`*STRING_LIST* splitByDelimiter(*STRING* str, *STRING* delimiter);`

*Description*: Returns a *STRING_LIST* of tokens after splitting
`str` by the `delimiter`.

'''

[#splitByWhitespace]
`*STRING_LIST* splitByWhitespace(*STRING* str);`

*Description*: Returns a *STRING_LIST* of tokens after splitting
`str` by whitespaces.

'''

[#splitProgram]
`*STRING_LIST* splitProgram(*STRING* program);`

*Description*: Returns a *STRING_LIST* after splitting SIMPLE program `program`
into strings containing the names, numbers, symbols that the Lexer can determine
based on SIMPLE syntax. All whitespace will be truncated from the strings.

[#trimWhitespace]
`*STRING* trimWhitespace(*STRING* str);`

*Description*: Given a string `str` that starts or ends with some whitespace
characters, or both starts and ends with whitespace characters, returns a
substring of 'str' with the starting and ending whitespaces truncated. If
the string consists only of whitespaces, return an empty string. If the
string does not contain any whitespaces (this includes the empty string),
return the same string `str`.
