= API Documentation
:toc:
This document provides the relevant techinical APIs exposed by each different component.

== Frontend
=== Parser API
*Overview*: The Parser API describes methods available to the parser of the Simple Program
Analyser (SPA). The main method, parseSimple, is the main entry point to the program,
where a SIMPLE program string is input for analysis.

* <<parseSimple>>
* <<parseExpression>>

'''

[#parseSimple]
`*VOID* parseSimple(*STRING* rawProgram) throws *SYNTAX_ERROR*;`

*Description*: Takes in a SIMPLE program string so the PKB can be populated with entries.
If the program string is not in valid SIMPLE syntax, or contains semantic errors,
an ERROR will be thrown. +

'''

[#parseExpression]
`*EXPRESSION* parseExpression(*STRING_LIST* lexedExpression);`

**Description**: Takes in a lexed SIMPLE expression, and returns an Abstract Syntax Tree (AST)
node that represents the expression. This method may be used to pattern-match queries.

=== Design Extractor API
*Overview*: The Design Extractor API describes methods available to the Design
Extractor of the Simple Program Analyser (SPA). In the Design Extractor, program
design entity relationships are identified and stored in the PKB. The main method,
extractDesign, provides the inputs required by the Design Extractor to determine
program design entity relationships, namely an Abstract Syntax Tree (AST) of a
SIMPLE program.

* <<extractDesign>>

'''

[#extractDesign]
`*VOID* extractDesign(*PROGRAM_NODE* rootNode) throws *SEMANTIC_ERROR*;`

*Description*: Takes in a SIMPLE AST and walks the tree, identifying the presence of
important relationships between program design entities. If the program contains
semantic errors, a SEMANTIC_ERROR will be thrown. +

=== Abstract Syntax Tree (AST) API
*Overview*: The AST API describes the methods available to construct an Abstract Syntax Tree
in the Simple Program Analyser (SPA).

==== Nodes API
*Overview*: The Nodes API describes the methods available to create Node representations
in the Simple Program Analyser (SPA).

* <<createAssignNode>>
* <<createCallNode>>
* <<createIfNode>>
* <<createPrintNode>>
* <<createProcedureNode>>
* <<createProgramNode>>
* <<createReadNode>>
* <<createStmtlstNode>>
* <<createWhileNode>>

'''

[#createAssignNode]
`*ASSIGNMENT_STATEMENT_NODE* createAssignNode(*STATEMENT_NUMBER* sn, *VARIABLE* var, *EXPRESSION* expr);`

*Description*: Creates and returns an *ASSIGNMENT_STATEMENT_NODE* with `var` and `expr` as the children,
and `sn` as its statement number.

'''

[#createCallNode]
`*CALL_STATEMENT_NODE* createCallNode(*STATEMENT_NUMBER* sn, *NAME* procName);`

*Description*: Creates and returns a *CALL_STATEMENT_NODE* with `procName` as the child,
and `sn` as its statement number.

'''

[#createIfNode]
`*IF_STATEMENT_NODE* createIfNode(*STATEMENT_NUMBER* sn, *CONDITIONAL_EXPRESSION* predicate,
*STMTLST_NODE* leftStatementList, *STMTLST_NODE* rightStatementList);`

*Description*: Creates and returns an *IF_STATEMENT_NODE* with the condition `predicate`,
`leftStatementList` and `rightStatementList` as the children,
and `sn` as its statement number.

'''

[#createPrintNode]
`*PRINT_STATEMENT_NODE* createPrintNode(*STATEMENT_NUMBER* sn, *VARIABLE* var);`

*Description*: Creates and returns a *PRINT_STATEMENT_NODE* with `var` as the child,
and `sn` as its statement number.

'''

[#createProcedureNode]
`*PROCEDURE_NODE* createProcedureNode(*NAME* procedureName, *STMTLST_NODE* stmtlstNode);`

*Description*: Creates and returns a *PROCEDURE_NODE* with `stmtlstNode` as the child,
and `procedureName` as the name of the procedure.

'''

[#createProgramNode]
`*PROGRAM_NODE* createProgramNode(*NAME* programName, *PROCEDURE_NODE_LIST* procedureNodes,
*STATEMENT_NUMBER* totalStmts);`

*Description*: Creates and returns a *PROGRAM_NODE* with `procedureNodes` as the child in a
*PROCEDURE_NODE_LIST* form, and `programName` as the name of the program. It also stores the
total number of statements `totalStmts`.

'''

[#createReadNode]
`*READ_STATEMENT_NODE* createReadNode(*STATEMENT_NUMBER* sn, *VARIABLE* var);`

*Description*: Creates and returns a *READ_STATEMENT_NODE* with `var` as the child,
and `sn` as its statement number.

'''

[#createStmtlstNode]
`*STMTLST_NODE* createStmtlstNode(*STATEMENT_NODE_LIST* statementNodes);`

*Description*: Creates and returns a *STMTLST_NODE* with `statementNodes` as its children;

'''

[#createWhileNode]
`*WHILE_STATEMENT_NODE* createWhileNode(*STATEMENT_NUMBER* sn, *CONDITIONAL_EXPRESSION* predicate,
*STMTLST_NODE* statementList);`

*Description*: Creates and returns an *WHILE_STATEMENT_NODE* with the condition `predicate`,
`statementList` as its children, and `sn` as its statement number.

==== Expressions API
*Overview*: The Expressions API describes the methods available to create Expression representations
in the Simple Program Analyser (SPA).

* <<createAndExpr>>
* <<createDivExpr>>
* <<createEqExpr>>
* <<createGtExpr>>
* <<createGteExpr>>
* <<createLtExpr>>
* <<createLteExpr>>
* <<createMinusExpr>>
* <<createModExpr>>
* <<createNeqExpr>>
* <<createNotExpr>>
* <<createOrExpr>>
* <<createPlusExpr>>
* <<createRefExpr>>
* <<createTimesExpr>>

[#createAndExpr]
`*AND_EXPRESSION* createAndExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *AND_EXPRESSION* where the truthy value depends on
both `leftExpr` and the `rightExpr`. This corresponds to the "```&&```" operation in SIMPLE.

'''

[#createDivExpr]
`*ARITHMETIC_EXPRESSION* createDivExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is divided
by the `rightExpr`. This corresponds to the "```/```" operation in SIMPLE.

'''

[#createEqExpr]
`*RELATIONAL_EXPRESSION* createEqExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is equal
to the `rightRelFactor`. This corresponds to the "```==```" operation in SIMPLE.

'''

[#createGtExpr]
`*RELATIONAL_EXPRESSION* createGtExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is greater
than the `rightRelFactor`. This corresponds to the "```>```" operation in SIMPLE.

'''

[#createGteExpr]
`*RELATIONAL_EXPRESSION* createGteExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is greater
than or equals to the `rightRelFactor`.  This corresponds to the "```>=```" operation in SIMPLE.

'''

[#createLtExpr]
`*RELATIONAL_EXPRESSION* createLtExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is lesser
than the `rightRelFactor`.  This corresponds to the "```<```" operation in SIMPLE.

'''

[#createLteExpr]
*`RELATIONAL_EXPRESSION* createLteExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is lesser
than or equals to the `rightRelFactor`.  This corresponds to the "```&lt;=```" operation in SIMPLE.

'''

[#createMinusExpr]
`*ARITHMETIC_EXPRESSION* createMinusExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is divided
by the `rightExpr`.  This corresponds to the "```-```" operation in SIMPLE.

'''

[#createModExpr]
`*ARITHMETIC_EXPRESSION* createModExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is mod
by the `rightExpr`. This corresponds to the "```%```" operation in SIMPLE.

'''

[#createNeqExpr]
`*RELATIONAL_EXPRESSION* createNeqExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is not
equal to the `rightRelFactor`. This corresponds to the "```!=```" operation in SIMPLE.

'''

[#createNotExpr]
`*NOT_EXPRESSION* createNotExpr(*CONDITIONAL_EXPRESSION* expr);`

*Description*: Creates and returns an *NOT_EXPRESSION* with the negated value of `expr`.
This corresponds to the "```!```" operation in SIMPLE.

'''

[#createOrExpr]
`*OR_EXPRESSION* createOrExpr(*CONDITIONAL_EXPRESSION* leftExpr, *CONDITIONAL_EXPRESSION* rightExpr);`

*Description*: Creates and returns an *OR_EXPRESSION* where the truthy value depends on
either `leftExpr` or the `rightExpr`. This corresponds to the "```||```" operation in SIMPLE.

'''

[#createPlusExpr]
`*ARITHMETIC_EXPRESSION* createPlusExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is added
to the `rightExpr`. This corresponds to the "```+```" operation in SIMPLE.

'''

[#createRefExpr]
`*REFERENCE_EXPRESSION* createRefExpr(*STRING* variable);`

`*REFERENCE_EXPRESSION* createRefExpr(*INTEGER* constant);`

*Description*: Creates and returns a *REFERENCE_EXPRESSION* based on `variable`
or `constant`. Reference expressions can be either a variable or a constant.
To create a reference expression based on a variable, pass the variable name
as a `STRING`, and to create a reference expression based
on a constant, pass the constant value as an `Integer`.

'''

[#createTimesExpr]
`*ARITHMETIC_EXPRESSION* createTimesExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an  *ARITHMETIC_EXPRESSION* where the `leftExpr` is multiplied
with the `rightExpr`. This corresponds to the "```*```" operation in SIMPLE.

==== AST Helper API
*Overview*: The AST Helper API describes useful methods that are
often used when dealing with an Abstract Syntax Tree.

* <<isContainerStatement>>

[#isContainerStatement]
`*BOOLEAN* isContainerStatement(*STATEMENT_TYPE* stmtType);`

*Description*: Returns true if `stmtType` corresponds to an "if" statement
or a "while" statement in SIMPLE. These statements contain other statements
of their own, hence they are also known as "container statements".

'''


== PKB

=== Statement Table API

*Overview*: The Statement Table API describes the methods available to extract information related to statements.

* <<getAllStatements>>
* <<isStatementInProgram>>
* <<insertIntoStatementTable>>

'''

[#getAllStatements]
`*STATEMENT_LIST* getAllStatements(*DESIGN_ENT_STMT_NAME* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all the statements in the Statement Table.

'''

[#isStatementInProgram]
`*BOOLEAN* isStatementInProgram(*INTEGER* number);`

*Description*: Returns a *BOOLEAN* stating whether statement is in the Statement Table.

'''

[#insertIntoStatementTable]
`*VOID* insertIntoStatementTable(*INTEGER* number, *STATEMENT_TYPE* type);`

*Description*: Inserts a *STATEMENT* `statement` with its corresponding *STATEMENT_TYPE* into the Statement Table.

=== Variable Table API

*Overview*: The Variable Table API describes the methods available to extract information related to variables in the processed SIMPLE program.

* <<getAllVariables>>
* <<isVariableInProgram>>
* <<insertIntoVariableTable>>

'''

[#getAllVariables]
`*VARIABLE_LIST* getAllVariables();`

*Description*: Returns a *VARIABLE_LIST* of all variables stored in the Variable Table.

'''

[#isVariableInProgram]
`*BOOLEAN* isVariableInProgram(*VARIABLE* var);`

*Description*: Returns a *BOOLEAN* stating whether variable is in the Variable Table.

'''

[#insertIntoVariableTable]
`*VOID* insertIntoVariableTable(*VARIABLE* var);`

*Description*: Inserts the *VARIABLE* `var` into Variable Table.

=== Procedure Table API

*Overview*: The Procedure Table API describes the methods available to extract information related to procedures in the processed SIMPLE program.

* <<getAllProcedures>>
* <<isProcedureInProgram>>
* <<insertIntoProcedureTable>>

'''

[#getAllProcedures]
`*PROCEDURE_LIST* getAllProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all procedures stored in the Procedure Table.

'''

[#isProcedureInProgram]
`*BOOLEAN* isProcedureInProgram(*PROCEDURE* proc);`

*Description*: Returns a *BOOLEAN* stating whether procedure is in the Procedure Table.

'''

[#insertIntoProcedureTable]
`*VOID* insertIntoProcedureTable(*PROCEDURE* proc);`

*Description*: Inserts the *PROCEDURE* `proc` into Procedure Table.

=== Constant Table API

*Overview*: The Constant Table API describes the methods available to extract information related to constants in the processed SIMPLE program.

* <<getAllConstants>>
* <<isConstantInProgram>>
* <<insertIntoConstantTable>>

'''

[#getAllConstants]
`*CONSTANT_LIST* getAllConstants();`

*Description*: Returns a *CONSTANT_LIST* of all constants stored in the Constant Table.

'''

[#isConstantInProgram]
`*BOOLEAN* isConstantInProgram(*CONSTANT* constant);`

*Description*: Returns a *BOOLEAN* stating whether `constant` is in the Constant Table.

'''

[#insertIntoConstantTable]
`*VOID* insertIntoConstantTable(*CONSTANT* constant);`

*Description*: Inserts the *CONSTANT* `constant` into Constant Table.

=== Uses API

*Overview*: The Uses API describes the methods available to extract information related to the Uses relationships in the processed SIMPLE program.

* <<addUsesRelationships>>
* <<checkIfProcedureUses>>
* <<checkIfStatementUses>>
* <<getAllUsesProcedures>>
* <<getAllUsesStatements>>
* <<getAllUsesVariables>>
* <<getUsesProcedures>>
* <<getUsesStatements>>
* <<getUsesVariablesFromStatement>>
* <<getUsesVariablesFromProcedure>>
* <<getAllUsesStatementTuple>>
* <<getAllUsesProcedureTuple>>

'''

[#addUsesRelationships]
`*VOID* addUsesRelationships(*INTEGER* stmt, *VARIABLE_LIST* varList);`

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are modified in `stmt`
to the Uses Table.

'''

[#checkIfProcedureUses]
`*PROCEDURE_LIST* checkIfProcedureUses(*STRING* proc, *STRING* var);`

*Description*: Returns the *PROCEDURE* in a *PROCEDURE_LIST* if `proc` uses `var`,
otherwise an empty *PROCEDURE_LIST* is returned.

'''

[#checkIfStatementUses]
`*STATEMENT_LIST* checkIfStatementUses(*INTEGER* stmt, *STRING* var);`

*Description*: Returns the `*STATEMENT*` in a STATEMENT_LIST if `stmt` uses `var`, otherwise
an empty *STATEMENT_LIST* is returned.

'''

[#getAllUsesProcedures]
`*PROCEDURE_LIST* getAllUsesProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all PROCEDURE that uses a *VARIABLE*.

'''

[#getAllUsesStatements]
`*STATEMENT_LIST* getAllUsesStatements(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all STATEMENT that uses a *VARIABLE*.

'''

[#getAllUsesVariables]
`*VARIABLE_LIST* getAllUsesVariables();`

Description: Returns a *VARIABLE_LIST* of all variables that are used in the SIMPLE program.

'''

[#getUsesProcedures]
`*PROCEDURE_LIST* getUsesProcedures(*VARIABLE* var);`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that uses a *VARIABLE* `var`.

'''

[#getUsesStatements]
`*STATEMENT_LIST* getUsesStatements(*VARIABLE* var, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`,
that uses *VARIABLE* `var`.

'''

[#getUsesVariablesFromStatement]
`*VARIABLE_LIST* getUsesVariablesFromStatement(*INTEGER* stmt);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that `stmt` uses.

'''

[#getUsesVariablesFromProcedure]
`*VARIABLE_LIST* getUsesVariablesFromProcedure(*PROCEDURE* proc);`

*Description*: Returns a *VARIABLE_LIST* of variables that were used in `proc`.

'''

[#getAllUsesStatementTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllUsesStatementTuple(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a list of all pairs where the first entry of the pair is a statement of the `stmtType`, while the second entry of the pair is a variable the statement uses.

'''

[#getAllUsesProcedureTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllUsesProcedureTuple();`

*Description*: Returns a list of all pairs where the first entry of the pair is a procedure, while the second entry of the pair is a variable the procedure uses.

=== Modifies API

*Overview*: The Modifies API describes the methods available to extract information related to the Modifies relationships in the processed SIMPLE program.

* <<addModifiesRelationships>>
* <<checkIfProcedureModifies>>
* <<checkIfStatementModifies>>
* <<getAllModifiesProcedures>>
* <<getAllModifiesStatements>>
* <<getAllModifiesVariables>>
* <<getModifiesProcedures>>
* <<getModifiesStatements>>
* <<getModifiesVariablesFromStatement>>
* <<getModifiesVariablesFromProcedure>>
* <<getAllModifiesStatementTuple>>
* <<getAllModifiesProcedureTuple>>

'''

[#addModifiesRelationships]
`*VOID* addModifiesRelationships(*INTEGER* stmt, *VARIABLE_LIST* varList);`

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are modified in `stmt`
to the Modifies Table.

'''

[#checkIfProcedureModifies]
`*PROCEDURE_LIST* checkIfProcedureModifies(*STRING* proc, *STRING* var);`

*Description*: Returns the *PROCEDURE* in a *PROCEDURE_LIST* if `proc` modifies `var`, otherwise an empty *PROCEDURE_LIST* is returned.

'''

[#checkIfStatementModifies]
`*STATEMENT_LIST* checkIfStatementModifies(*INTEGER* stmt, *STRING* var);`

*Description*: Returns the `*STATEMENT*` in a STATEMENT_LIST if `stmt` modifies `var`, otherwise an empty *STATEMENT_LIST* is returned.

'''

[#getAllModifiesProcedures]
`*PROCEDURE_LIST* getAllModifiesProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all PROCEDURE that modifies a *VARIABLE*.

'''

[#getAllModifiesStatements]
`*STATEMENT_LIST* getAllModifiesStatements(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all STATEMENT that modifies a *VARIABLE*.

'''

[#getAllModifiesVariables]
`*VARIABLE_LIST* getAllModifiesVariables();`

Description: Returns a *VARIABLE_LIST* of all variables that are modified in the SIMPLE program.

'''

[#getModifiesProcedures]
`*PROCEDURE_LIST* getModifiesProcedures(*VARIABLE* var);`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that modifies a *VARIABLE* `var`.

'''

[#getModifiesStatements]
`*STATEMENT_LIST* getModifiesStatements(*VARIABLE* var, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`, that modifies *VARIABLE* `var`.

'''

[#getModifiesVariablesFromStatement]
`*VARIABLE_LIST* getModifiesVariablesFromStatement(*INTEGER* stmt);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that `stmt` modifies.

'''

[#getModifiesVariablesFromProcedure]
`*VARIABLE_LIST* getModifiesVariablesFromProcedure(*PROCEDURE* proc);`

*Description*: Returns a *VARIABLE_LIST* of variables that were modified in `proc`.

'''

[#getAllModifiesStatementTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllModifiesStatementTuple(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a list of all pairs where the first entry of the pair is a statement of the `stmtType`, while the second entry of the pair is a variable the statement modifies.

'''

[#getAllModifiesProcedureTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllModifiesProcedureTuple();`

*Description*: Returns a list of all pairs where the first entry of the pair is a procedure, while the second entry of the pair is a variable the procedure modifies.

=== Parent API

*Overview*: The Parent API describes the methods exposed by Parent Table to insert and extract information related to the Parent relationships in the processed SIMPLE program.

* <<addParentRelationships>>
* <<addParentRelationshipsStar>>
* <<checkIfParentHolds>>
* <<checkIfParentStarHolds>>
* <<getChildStatement>>
* <<getAllChildStatementsStar>>
* <<getAllChildStatementsTyped>>
* <<getAllChildStatementsTypedStar>>
* <<getParentStatement>>
* <<getAllParentStatementsStar>>
* <<getAllParentStatementsTyped>>
* <<getAllParentStatementsTypedStar>>
* <<getAllParentTuple>>
* <<getAllParentTupleStar>>

'''

[#addParentRelationships]
`*VOID* addParentRelationships(*INTEGER* parent, *STATEMENT_TYPE*, parentType, *INTEGER* child,
*STATEMENT_TYPE* childType);`

*Description*: Adds a Parent relationship between `parent` with `parentType` and `child`
with `childType` into the Parent Table.

'''

[#addParentRelationshipsStar]
`*VOID* addParentRelationshipsStar(*INTEGER* parent, *STATEMENT_TYPE* parentType,
*LIST<PAIR<STATEMENT, STATEMENT_TYPE>>* childrenWithTYpe);`

*Description*: Adds a Parent relationship between `parent` with `parentType` and all
`childrenWithType` into the Parent Table.

'''

[#checkIfParentHolds]
`*BOOLEAN* checkIfParentHolds(*INTEGER* parent, *INTEGER* child);`

*Description*: Returns `TRUE` if there is a Parent relationship between `parent` and `child`, else return `FALSE`.

'''

[#checkIfParentStarHolds]
`*BOOLEAN* checkIfParentStarHolds(*INTEGER* parent, *INTEGER* child);`

*Description*: Returns `TRUE` if there is a Parent* relationship between `parent` and `child`, else return `FALSE`.

'''

[#getChildStatement]
`*STATEMENT_LIST* getChildStatement(*INTEGER* parent);`

*Description*: Returns a *STATEMENT_LIST* containing the child *STATEMENT* of `parent`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `parent`.

'''

[#getAllChildStatementsStar]
`*STATEMENT_LIST* getAllChildStatementsStar(*INTEGER* parent, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all _transitive_ child *STATEMENT* of `parent`.
Child *STATEMENT* are of *STATEMENT_TYPE* `stmtType`.

'''

[#getAllChildStatementsTyped]
`*STATEMENT_LIST* getAllChildStatementsTyped(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all children that are of *STATEMENT_TYPE*
`stmtTypeOfChild`, with a child of *STATEMENT_TYPE* `stmtTypeOfParent`.

'''

[#getAllChildStatementsTypedStar]
`*STATEMENT_LIST* getAllChildStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all children that are of *STATEMENT_TYPE*
`stmtTypeOfChild`, with a _transitive_ Parent of *STATEMENT_TYPE* `stmtTypeOfParent`.

'''

[#getParentStatement]
`*STATEMENT_LIST* getParentStatement(*INTEGER* child);`

*Description*: Returns a *STATEMENT_LIST* containing the parent *STATEMENT* of `child`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `child`.

'''

[#getAllParentStatementsStar]
`*STATEMENT_LIST* getAllParentStatementsStar(*INTEGER* child, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all _transitive_ Parent of `child`.
Parents are of STATEMENT_TYPE `stmtType`.

'''

[#getAllParentStatementsTyped]
`*STATEMENT_LIST* getAllParentStatementsTyped(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all Parents that are of *STATEMENT_TYPE*
`stmtTypeOfParent`, with a child of *STATEMENT_TYPE* `stmtTypeOfChild`.

'''

[#getAllParentStatementsTypedStar]
`*STATEMENT_LIST* getAllParentStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all Parents that are of *STATEMENT_TYPE*
`stmtTypeOfParent`, with a _transitive_ child of *STATEMENT_TYPE* `stmtTypeOfChild`.

'''

[#getAllParentTuple]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllParentTuple(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a list of pairs, where for each pair, the *Parent* relationship holds between them, and the parent is of `stmtTypeOfParent`, and the child is of `stmtTypeOfChild`.

'''

[#getAllParentTupleStar]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllParentTupleStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a list of pairs, where for each pair, the *Parent** relationship holds between them, and the parent is of `stmtTypeOfParent`, and the child is of `stmtTypeOfChild`.

=== Before API

*Overview*: The Before API describes the methods exposed by Before Table to insert and extract information related to the Before relationships in the processed SIMPLE program.

* <<addBeforeRelationships>>
* <<addBeforeRelationshipsStar>>
* <<checkIfBeforeHolds>>
* <<checkIfBeforeStarHolds>>
* <<getAfterStatement>>
* <<getAllAfterStatementsStar>>
* <<getAllAfterStatementsTyped>>
* <<getAllAfterStatementsTypedStar>>
* <<getBeforeStatement>>
* <<getAllBeforeStatementsStar>>
* <<getAllBeforeStatementsTyped>>
* <<getAllBeforeStatementsTypedStar>>
* <<getAllFollowsTuple>>
* <<getAllFollowsTupleStar>>

'''

[#addBeforeRelationships]
`*VOID* addBeforeRelationships(*INTEGER* before, *STATEMENT_TYPE*, beforeType, *INTEGER* after,
*STATEMENT_TYPE* afterType);`

*Description*: Adds a Before relationship between `before` with `beforeType` and `after`
with `afterType` into the Before Table.

'''

[#addBeforeRelationshipsStar]
`*VOID* addBeforeRelationshipsStar(*INTEGER* before, *STATEMENT_TYPE* beforeType,
*LIST<PAIR<STATEMENT, STATEMENT_TYPE>>* afterWithTYpe);`

*Description*: Adds a Before relationship between `before` with `beforeType` and all
`afterWithType` into the Before Table.

'''

[#checkIfBeforeHolds]
`*BOOLEAN* checkIfBeforeHolds(*INTEGER* before, *INTEGER* after);`

*Description*: Returns `TRUE` if there is a Follows relationship between `before` and `after`, else return `FALSE`.

'''

[#checkIfBeforeStarHolds]
`*BOOLEAN* checkIfBeforeStarHolds(*INTEGER* before, *INTEGER* after);`

*Description*: Returns `TRUE` if there is a Follows* relationship between `before` and `after`, else return `FALSE`.

'''

[#getAfterStatement]
`*STATEMENT_LIST* getAfterStatement(*INTEGER* before);`

*Description*: Returns a *STATEMENT_LIST* containing the after *STATEMENT* of `before`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `before`.

'''

[#getAllAfterStatementsStar]
`*STATEMENT_LIST* getAllAfterStatementsStar(*INTEGER* before, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of statements such that `Follows(before,returned)`
holds and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllAfterStatementsTyped]
`*STATEMENT_LIST* getAllAfterStatementsTyped(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of statements such that `Follows*(before,returned)`
holds and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllAfterStatementsTypedStar]
`*STATEMENT_LIST* getAllAfterStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all after statements that are of *STATEMENT_TYPE*
`stmtTypeOfAfter`, with a _transitive_ Follows of *STATEMENT_TYPE* `stmtTypeOfBefore`.

'''

[#getBeforeStatement]
`*STATEMENT_LIST* getBeforeStatement(*INTEGER* after);`

*Description*: Returns a *STATEMENT_LIST* containing the before *STATEMENT* of `after`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `after`.

'''

[#getAllBeforeStatementsStar]
`*STATEMENT_LIST* getAllBeforeStatementsStar(*INTEGER* after, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of statements that are before* `after` and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllBeforeStatementsTyped]
`*STATEMENT_LIST* getAllBeforeStatementsTyped(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all before statements that are of *STATEMENT_TYPE*
`stmtTypeOfBefore`, with a after of *STATEMENT_TYPE* `stmtTypeOfAfter`.

'''

[#getAllBeforeStatementsTypedStar]
`*STATEMENT_LIST* getAllBeforeStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all before statements that are of *STATEMENT_TYPE*
`stmtTypeOfBefore`, with a _transitive_ after of *STATEMENT_TYPE* `stmtTypeOfAfter`.

'''

[#getAllFollowsTuple]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllFollowsTuple(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a list of pairs, where for each pair, the *Before* relationship holds between them, and the before is of `stmtTypeOfBefore`, and the after is of `stmtTypeOfAfter`.

'''

[#getAllFollowsTupleStar]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllFollowsTupleStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a list of pairs, where for each pair, the *Before** relationship holds between them, and the before is of `stmtTypeOfBefore`, and the after is of `stmtTypeOfAfter`.

=== Utilities API

* <<resetPKB>>
* <<assignRootNode>>
* <<getRootNode>>

'''

[#resetPKB]
`*VOID* resetPKB()`

*Description*: An irreversible action resetting *ALL* information stored in *PKB*, as well as deleting the `RootNode` saved in PKB from memory.

'''

[#assignRootNode]
`*VOID* assignRootNode(*ROOT_NODE* rootNode)`

*Description*: Assign *rootNode* to be the root node for the AST for the SIMPLE program.

'''

[#getRootNode]
`*ROOT_NODE* getRootNode()`

*Description*: Get *rootNode* stored in PKB. If <<assignRootNode>> was never called, a *NULL_POINTER* will be returned.

== PQL

=== PQLManager API
*Overview*: Handles the business logic for processing and evaluating Processed
Query Language (PQL) queries.

* <<execute>>

'''

[#execute]
`*FORMATTED_QUERY_RESULT* execute(*STRING* query);`

*Description*: Returns a *FORMATTED_QUERY_RESULT* after processing and evaluating a
`query` in *Processed Query Language* (PQL) form.

=== PreProcessor API
*Overview*: Handles the business logic for pre-processing PQL queries, including validating
syntax and semantics.

* <<processQuery>>

'''

[#processQuery]
`*ABSTRACT_QUERY* processQuery(*STRING* query);`

*Description*: Returns an *ABSTRACT_QUERY* after validating and breaking down the `query`.

=== Evaluator API
*Overview*: Evaluates the processed query and obtain a result for it by interacting
with the PKB.

* <<evaluateQuery>>

'''

[#evaluateQuery]
`*RAW_QUERY_RESULT* evaluateQuery(*STRING* query);`

*Description*: Returns a *RAW_QUERY_RESULT* after evaluating the `query` and obtaining information
from the PKB.

=== Projector API
*Overview*: Formats query results into human readable context.

* <<formatResult>>

'''

[#formatResult]
`*FORMATTED_RESULT* formatResult(*RAW_QUERY_RESULT* rawQueryResult);`

*Description*: Returns a *FORMATTED_RESULT* after formatting `rawQueryResult` to
a conforming standard.

== Shared Libraries (for internal use)

=== Lexer API

* <<isWhitespace>>
* <<splitByDelimiter>>
* <<splitByWhitespace>>
* <<splitProgram>>
* <<trimWhitespace>>

'''

[#isWhitespace]
`*BOOLEAN* isWhitespace(*CHAR** c);`

*Description*: Returns true if *CHAR* `c` is a whitespace character, and vice versa.

'''

[#splitByDelimiter]
`*STRING_LIST* splitByDelimiter(*STRING* str, *STRING* delimiter);`

*Description*: Returns a *STRING_LIST* of tokens after splitting
`str` by the `delimiter`.

'''

[#splitByWhitespace]
`*STRING_LIST* splitByWhitespace(*STRING* str);`

*Description*: Returns a *STRING_LIST* of tokens after splitting
`str` by whitespaces.

'''

[#splitProgram]
`*STRING_LIST* splitProgram(*STRING* program);`

*Description*: Returns a *STRING_LIST* after splitting SIMPLE program `program`
into strings containing the names, numbers, symbols that the Lexer can determine
based on SIMPLE syntax.All whitespace will be truncated from the strings.

[#trimWhitespace]
`*STRING* trimWhitespace(*STRING* str);`

*Description*: Given a string `str` that starts or ends with some whitespace
characters, or both starts and ends with whitespace characters, returns a
substring of 'str' with the starting and ending whitespaces truncated.If
the string consists only of whitespaces, return an empty string.If the
string does not contain any whitespaces (this includes the empty string),
return the same string `str`.
