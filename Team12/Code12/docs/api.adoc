= API Documentation
:toc:
This document provides the relevant techinical APIs exposed by each different component.

== Frontend
=== Parser API
*Overview*: The Parser API describes methods available to the parser of the Simple Program
Analyser (SPA). The main method, parseSimple, is the main entry point to the program,
where a SIMPLE program string is input for analysis.

* <<parseSimple>>
* <<parseExpression>>

'''

[#parseSimple]
`*VOID* parseSimple(*STRING* rawProgram) throws *SYNTAX_ERROR*;`

*Description*: Takes in a SIMPLE program string so the PKB can be populated with entries.
If the program string is not in valid SIMPLE syntax, or contains semantic errors,
an ERROR will be thrown. +

'''

[#parseExpression]
`*EXPRESSION* parseExpression(*STRING_LIST* lexedExpression);`

**Description**: Takes in a lexed SIMPLE expression, and returns an Abstract Syntax Tree (AST)
node that represents the expression. This method may be used to pattern-match queries.

=== Design Extractor API
*Overview*: The Design Extractor API describes methods available to the Design
Extractor of the Simple Program Analyser (SPA). In the Design Extractor, program
design entity relationships are identified and stored in the PKB. The main method,
extractDesign, provides the inputs required by the Design Extractor to determine
program design entity relationships, namely an Abstract Syntax Tree (AST) of a
SIMPLE program.

* <<extractDesign>>

'''

[#extractDesign]
`*VOID* extractDesign(*PROGRAM_NODE* rootNode) throws *SEMANTIC_ERROR*;`

*Description*: Takes in a SIMPLE AST and walks the tree, identifying the presence of
important relationships between program design entities. If the program contains
semantic errors, a SEMANTIC_ERROR will be thrown. +

=== Abstract Syntax Tree (AST) API
*Overview*: The AST API describes the methods available to construct an Abstract Syntax Tree
in the Simple Program Analyser (SPA).

==== Nodes API
*Overview*: The Nodes API describes the methods available to create Node representations
in the Simple Program Analyser (SPA).

* <<createAssignNode>>
* <<createCallNode>>
* <<createIfNode>>
* <<createPrintNode>>
* <<createProcedureNode>>
* <<createProgramNode>>
* <<createReadNode>>
* <<createStmtlstNode>>
* <<createWhileNode>>

'''

[#createAssignNode]
`*ASSIGNMENT_STATEMENT_NODE* createAssignNode(*STATEMENT_NUMBER* sn, *VARIABLE* var, *EXPRESSION* expr);`

*Description*: Creates and returns an *ASSIGNMENT_STATEMENT_NODE* with `var` and `expr` as the children,
and `sn` as its statement number.

'''

[#createCallNode]
`*CALL_STATEMENT_NODE* createCallNode(*STATEMENT_NUMBER* sn, *NAME* procName);`

*Description*: Creates and returns a *CALL_STATEMENT_NODE* with `procName` as the child,
and `sn` as its statement number.

'''

[#createIfNode]
`*IF_STATEMENT_NODE* createIfNode(*STATEMENT_NUMBER* sn, *CONDITIONAL_EXPRESSION* predicate,
*STMTLST_NODE* leftStatementList, *STMTLST_NODE* rightStatementList);`

*Description*: Creates and returns an *IF_STATEMENT_NODE* with the condition `predicate`,
`leftStatementList` and `rightStatementList` as the children,
and `sn` as its statement number.

'''

[#createPrintNode]
`*PRINT_STATEMENT_NODE* createPrintNode(*STATEMENT_NUMBER* sn, *VARIABLE* var);`

*Description*: Creates and returns a *PRINT_STATEMENT_NODE* with `var` as the child,
and `sn` as its statement number.

'''

[#createProcedureNode]
`*PROCEDURE_NODE* createProcedureNode(*NAME* procedureName, *STMTLST_NODE* stmtlstNode);`

*Description*: Creates and returns a *PROCEDURE_NODE* with `stmtlstNode` as the child,
and `procedureName` as the name of the procedure.

'''

[#createProgramNode]
`*PROGRAM_NODE* createProgramNode(*NAME* programName, *PROCEDURE_NODE_LIST* procedureNodes,
*STATEMENT_NUMBER* totalStmts);`

*Description*: Creates and returns a *PROGRAM_NODE* with `procedureNodes` as the child in a
*PROCEDURE_NODE_LIST* form, and `programName` as the name of the program. It also stores the
total number of statements `totalStmts`.

'''

[#createReadNode]
`*READ_STATEMENT_NODE* createReadNode(*STATEMENT_NUMBER* sn, *VARIABLE* var);`

*Description*: Creates and returns a *READ_STATEMENT_NODE* with `var` as the child,
and `sn` as its statement number.

'''

[#createStmtlstNode]
`*STMTLST_NODE* createStmtlstNode(*STATEMENT_NODE_LIST* statementNodes);`

*Description*: Creates and returns a *STMTLST_NODE* with `statementNodes` as its children;

'''

[#createWhileNode]
`*WHILE_STATEMENT_NODE* createWhileNode(*STATEMENT_NUMBER* sn, *CONDITIONAL_EXPRESSION* predicate,
*STMTLST_NODE* statementList);`

*Description*: Creates and returns an *WHILE_STATEMENT_NODE* with the condition `predicate`,
`statementList` as its children, and `sn` as its statement number.

==== Expressions API
*Overview*: The Expressions API describes the methods available to create Expression representations
in the Simple Program Analyser (SPA).

* <<createAndExpr>>
* <<createDivExpr>>
* <<createEqExpr>>
* <<createGtExpr>>
* <<createGteExpr>>
* <<createLtExpr>>
* <<createLteExpr>>
* <<createMinusExpr>>
* <<createModExpr>>
* <<createNeqExpr>>
* <<createNotExpr>>
* <<createOrExpr>>
* <<createPlusExpr>>
* <<createRefExpr>>
* <<createTimesExpr>>

[#createAndExpr]
`*AND_EXPRESSION* createAndExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *AND_EXPRESSION* where the truthy value depends on
both `leftExpr` and the `rightExpr`. This corresponds to the "```&&```" operation in SIMPLE.

'''

[#createDivExpr]
`*ARITHMETIC_EXPRESSION* createDivExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is divided
by the `rightExpr`. This corresponds to the "```/```" operation in SIMPLE.

'''

[#createEqExpr]
`*RELATIONAL_EXPRESSION* createEqExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is equal
to the `rightRelFactor`. This corresponds to the "```==```" operation in SIMPLE.

'''

[#createGtExpr]
`*RELATIONAL_EXPRESSION* createGtExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is greater
than the `rightRelFactor`. This corresponds to the "```>```" operation in SIMPLE.

'''

[#createGteExpr]
`*RELATIONAL_EXPRESSION* createGteExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is greater
than or equals to the `rightRelFactor`.  This corresponds to the "```>=```" operation in SIMPLE.

'''

[#createLtExpr]
`*RELATIONAL_EXPRESSION* createLtExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is lesser
than the `rightRelFactor`.  This corresponds to the "```<```" operation in SIMPLE.

'''

[#createLteExpr]
*`RELATIONAL_EXPRESSION* createLteExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is lesser
than or equals to the `rightRelFactor`.  This corresponds to the "```&lt;=```" operation in SIMPLE.

'''

[#createMinusExpr]
`*ARITHMETIC_EXPRESSION* createMinusExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is divided
by the `rightExpr`.  This corresponds to the "```-```" operation in SIMPLE.

'''

[#createModExpr]
`*ARITHMETIC_EXPRESSION* createModExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is mod
by the `rightExpr`. This corresponds to the "```%```" operation in SIMPLE.

'''

[#createNeqExpr]
`*RELATIONAL_EXPRESSION* createNeqExpr(*EXPRESSION* leftRelFactor, *EXPRESSION* rightRelFactor);`

*Description*: Creates and returns a *RELATIONAL_EXPRESSION* where the `leftRelFactor` is not
equal to the `rightRelFactor`. This corresponds to the "```!=```" operation in SIMPLE.

'''

[#createNotExpr]
`*NOT_EXPRESSION* createNotExpr(*CONDITIONAL_EXPRESSION* expr);`

*Description*: Creates and returns an *NOT_EXPRESSION* with the negated value of `expr`.
This corresponds to the "```!```" operation in SIMPLE.

'''

[#createOrExpr]
`*OR_EXPRESSION* createOrExpr(*CONDITIONAL_EXPRESSION* leftExpr, *CONDITIONAL_EXPRESSION* rightExpr);`

*Description*: Creates and returns an *OR_EXPRESSION* where the truthy value depends on
either `leftExpr` or the `rightExpr`. This corresponds to the "```||```" operation in SIMPLE.

'''

[#createPlusExpr]
`*ARITHMETIC_EXPRESSION* createPlusExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an *ARITHMETIC_EXPRESSION* where the `leftExpr` is added
to the `rightExpr`. This corresponds to the "```+```" operation in SIMPLE.

'''

[#createRefExpr]
`*REFERENCE_EXPRESSION* createRefExpr(*STRING* variable);`

`*REFERENCE_EXPRESSION* createRefExpr(*INTEGER* constant);`

*Description*: Creates and returns a *REFERENCE_EXPRESSION* based on `variable`
or `constant`. Reference expressions can be either a variable or a constant.
To create a reference expression based on a variable, pass the variable name
as a `STRING`, and to create a reference expression based
on a constant, pass the constant value as an `Integer`.

'''

[#createTimesExpr]
`*ARITHMETIC_EXPRESSION* createTimesExpr(*EXPRESSION* leftExpr, *EXPRESSION* rightExpr);`

*Description*: Creates and returns an  *ARITHMETIC_EXPRESSION* where the `leftExpr` is multiplied
with the `rightExpr`. This corresponds to the "```*```" operation in SIMPLE.

==== AST Helper API
*Overview*: The AST Helper API describes useful methods that are
often used when dealing with an Abstract Syntax Tree.

* <<isContainerStatement>>

[#isContainerStatement]
`*BOOLEAN* isContainerStatement(*STATEMENT_TYPE* stmtType);`

*Description*: Returns true if `stmtType` corresponds to an "if" statement
or a "while" statement in SIMPLE. These statements contain other statements
of their own, hence they are also known as "container statements".

'''


== PKB

=== Statement Table API

*Overview*: The Statement Table API describes the methods available to extract information related to statements.

* <<getAllStatements>>
* <<isStatementInProgram>>
* <<getProcedureCalled>>
* <<getAllCallStatementsByProcedure>>
* <<getAllProceduresCalled>>
* <<insertIntoStatementTable>>

'''

[#getAllStatements]
`*STATEMENT_LIST* getAllStatements(*DESIGN_ENT_STMT_NAME* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all the statements in the Statement Table.

'''

[#isStatementInProgram]
`*BOOLEAN* isStatementInProgram(*INTEGER* stmtNum);`

*Description*: Returns a *BOOLEAN* stating whether statement with `stmtNum` is in the Statement Table.

'''

[#getProcedureCalled]
`*PROCEDURE_LIST* getProcedureCalled(*INTEGER* stmtNum);`

*Description*: Returns the *PROCEDURE* called by the statement with `stmtNum`.If the statement is
not a *Call Statement*, an empty list is returned.

'''

[#getAllCallStatementsByProcedure]
`*STATEMENT_LIST* getAllCallStatementsByProcedure(*PROCEDURE* proc);`

*Description*: Returns a *STATEMENT_LIST* of statements that called `proc`.If `proc` is not a valid
*PROCEDURE* or is not called by any *Call Statement*, returns an empty list.

'''

[#getAllProceduresCalled]
`*PROCEDURE_LIST* getAllProceduresCalled();`

*Description*: Returns a *PROCEDURE_LIST* of procedures called by any *Call Statements*.
An empty list is returned if there are no *Call Statements* in the SIMPLE program.

'''

[#insertIntoStatementTable]
`*VOID* insertIntoStatementTable(*INTEGER* stmtNum, *STATEMENT_TYPE* type);`

*Requires*: `type` cannot be `AnyStatement` or `CallStatement` type.

*Description*: Inserts a statement with `stmtNum` with its corresponding *STATEMENT_TYPE* into the Statement Table.
If a same `stmtNum` already exists in the table, the old record will be overwritten without confirmation.

'''

`*VOID* insertIntoStatementTable(*INTEGER* stmtNum, *PROCEDURE_NAME* procName);`

*Description*: This is the insertion method for *Calls Statements* only.
Inserts a *Call Statement* with `stmtNum` with the name of the *Procedure* it calls into the Statement Table.
If a same `stmtNum` already exists in the table, any attributes associated with that statement will be overwritten.

=== Variable Table API

*Overview*: The Variable Table API describes the methods available to extract information related to variables in the processed SIMPLE program.

* <<getAllVariables>>
* <<isVariableInProgram>>
* <<insertIntoVariableTable>>

'''

[#getAllVariables]
`*VARIABLE_LIST* getAllVariables();`

*Description*: Returns a *VARIABLE_LIST* of all variables stored in the Variable Table.

'''

[#isVariableInProgram]
`*BOOLEAN* isVariableInProgram(*VARIABLE* var);`

*Description*: Returns a *BOOLEAN* stating whether variable is in the Variable Table.

'''

[#insertIntoVariableTable]
`*VOID* insertIntoVariableTable(*VARIABLE* var);`

*Description*: Inserts the *VARIABLE* `var` into Variable Table.
If a `var` with the same name already exist in the Variable Table, then no change will occur in the Variable Table.

=== Procedure Table API

*Overview*: The Procedure Table API describes the methods available to extract information related to procedures in the processed SIMPLE program.

* <<getAllProcedures>>
* <<isProcedureInProgram>>
* <<getStatementRangeByProcedure>>
* <<getContainingProcedure>>
* <<insertIntoProcedureTable>>

'''

[#getAllProcedures]
`*PROCEDURE_LIST* getAllProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all procedures stored in the Procedure Table.

'''

[#isProcedureInProgram]
`*BOOLEAN* isProcedureInProgram(*PROCEDURE* proc);`

*Description*: Returns a *BOOLEAN* stating whether procedure is in the Procedure Table.

'''

[#getStatementRangeByProcedure]
`*STATEMENT_RANGE* getStatementRangeByProcedure(*PROCEDURE* proc);`

*Description*: Returns a *STATEMENT_RANGE* within the `proc`.
If `proc` is not found in Procedure Table, returns the statement range `(0,0)`.

'''

[#getContainingProcedure]
`*PROCEDURE_LIST* getContainingProcedure(*STATEMENT* stmt);`

*Description*: Returns a *PROCEDURE_LIST* containing the procedure in which `stmt` is found, otherwise an empty *PROCEDURE_LIST* is returned.

'''

[#insertIntoProcedureTable]
`*VOID* insertIntoProcedureTable(*PROCEDURE* proc, *STATEMENT_LIST* statements);`

*Description*: Inserts the *PROCEDURE* `proc` and the `statements` it contain into Procedure Table.
This method is idempotent - repeated `proc` with different statements cause a union of statements recorded
in PKB associated with the same `proc`.

=== Constant Table API

*Overview*: The Constant Table API describes the methods available to extract information related to constants in the processed SIMPLE program.

* <<getAllConstants>>
* <<isConstantInProgram>>
* <<insertIntoConstantTable>>

'''

[#getAllConstants]
`*CONSTANT_LIST* getAllConstants();`

*Description*: Returns a *CONSTANT_LIST* of all constants stored in the Constant Table.

'''

[#isConstantInProgram]
`*BOOLEAN* isConstantInProgram(*CONSTANT* constant);`

*Description*: Returns a *BOOLEAN* stating whether `constant` is in the Constant Table.

'''

[#insertIntoConstantTable]
`*VOID* insertIntoConstantTable(*CONSTANT* constant);`

*Description*: Inserts the *CONSTANT* `constant` into Constant Table.
If a same `constant`
already exist in the Variable Table, then no change will occur in the Constant Table.

=== Uses API

*Overview*: The Uses API describes the methods available to extract information related to the Uses relationships in the processed SIMPLE program.

* <<addUsesRelationships>>
* <<checkIfProcedureUses>>
* <<checkIfStatementUses>>
* <<getAllUsesProcedures>>
* <<getAllUsesStatements>>
* <<getAllUsesVariables>>
* <<getUsesProcedures>>
* <<getUsesStatements>>
* <<getUsesVariablesFromStatement>>
* <<getUsesVariablesFromProcedure>>
* <<getAllUsesVariablesFromStatementType>>
* <<getAllUsesVariablesFromProgram>>
* <<getAllUsesStatementTuple>>
* <<getAllUsesProcedureTuple>>

'''

[#addUsesRelationships]
`*VOID* addUsesRelationships(*INTEGER* stmt, *STATEMENT_TYPE* stmtType, *VARIABLE_LIST* varList);`

*Requires*: `type` cannot be `AnyStatement` type.

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are used in `stmt`
to the Uses Table.

`*VOID* addUsesRelationships(*PROCEDURE* proc, *VARIABLE_LIST* varList);`

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are used in `proc`
to the Uses Table.

'''

[#checkIfProcedureUses]
`*BOOLEAN* checkIfProcedureUses(*STRING* proc, *STRING* var);`

*Description*: Returns `TRUE` if `proc` uses `var`, `FALSE` otherwise.

'''

[#checkIfStatementUses]
`*BOOLEAN* checkIfStatementUses(*INTEGER* stmt, *STRING* var);`

*Description*: Returns `TRUE` if `stmt` uses `var`, `FALSE` otherwise.

'''

[#getAllUsesProcedures]
`*PROCEDURE_LIST* getAllUsesProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all PROCEDURE that uses a *VARIABLE*.

'''

[#getAllUsesStatements]
`*STATEMENT_LIST* getAllUsesStatements(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all STATEMENT that uses a *VARIABLE*.

'''

[#getAllUsesVariables]
`*VARIABLE_LIST* getAllUsesVariables();`

Description: Returns a *VARIABLE_LIST* of all variables that are used in the SIMPLE program.

'''

[#getUsesProcedures]
`*PROCEDURE_LIST* getUsesProcedures(*VARIABLE* var);`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that uses a *VARIABLE* `var`.

'''

[#getUsesStatements]
`*STATEMENT_LIST* getUsesStatements(*VARIABLE* var, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`,
that uses *VARIABLE* `var`.

'''

[#getUsesVariablesFromStatement]
`*VARIABLE_LIST* getUsesVariablesFromStatement(*INTEGER* stmt);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that `stmt` uses.

'''

[#getUsesVariablesFromProcedure]
`*VARIABLE_LIST* getUsesVariablesFromProcedure(*PROCEDURE* proc);`

*Description*: Returns a *VARIABLE_LIST* of variables that were used in `proc`.

'''

[#getAllUsesVariablesFromStatementType]
`*VARIABLE_LIST* getUsesVariablesFromStatementType(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that is used by any *STATEMENT* of type `stmtType`.

'''

[#getAllUsesVariablesFromProgram]
`*VARIABLE_LIST* getAllUsesVariablesFromProgram();`

*Description*: Returns a *VARIABLE_LIST* of variables that were used in any *PROCEDURE*.

'''

[#getAllUsesStatementTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllUsesStatementTuple(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a list of all pairs where the first entry of the pair is a statement of the `stmtType`, while the second entry of the pair is a variable the statement uses.

'''

[#getAllUsesProcedureTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllUsesProcedureTuple();`

*Description*: Returns a list of all pairs where the first entry of the pair is a procedure, while the second entry of the pair is a variable the procedure uses.

=== Modifies API

*Overview*: The Modifies API describes the methods available to extract information related to the Modifies relationships in the processed SIMPLE program.

* <<addModifiesRelationships>>
* <<checkIfProcedureModifies>>
* <<checkIfStatementModifies>>
* <<getAllModifiesProcedures>>
* <<getAllModifiesStatements>>
* <<getAllModifiesVariables>>
* <<getModifiesProcedures>>
* <<getModifiesStatements>>
* <<getModifiesVariablesFromStatement>>
* <<getModifiesVariablesFromProcedure>>
* <<getAllModifiesVariablesFromStatementType>>
* <<getAllModifiesVariablesFromProgram>>
* <<getAllModifiesStatementTuple>>
* <<getAllModifiesProcedureTuple>>

'''

[#addModifiesRelationships]
`*VOID* addModifiesRelationships(*INTEGER* stmt, *STATEMENT_TYPE* stmtType, *VARIABLE_LIST* varList);`

*Requires*: `type` cannot be `AnyStatement` type.

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are modified in `stmt`
to the Modifies Table.

`*VOID* addModifiesRelationships(*PROCEDURE* proc, *VARIABLE_LIST* varList);`

*Description*: Add all variables in *VARIABLES_LIST* `varList` that are modified in `proc`
to the Modifies Table.

'''

[#checkIfProcedureModifies]
`*BOOLEAN* checkIfProcedureModifies(*STRING* proc, *STRING* var);`

*Description*: Returns `TRUE` if `proc` modifies `var`, `FALSE` otherwise.

'''

[#checkIfStatementModifies]
`*BOOLEAN* checkIfStatementModifies(*INTEGER* stmt, *STRING* var);`

*Description*: Returns `TRUE` if `stmt` modifies `var`, `FALSE` otherwise.

'''

[#getAllModifiesProcedures]
`*PROCEDURE_LIST* getAllModifiesProcedures();`

*Description*: Returns a *PROCEDURE_LIST* of all PROCEDURE that modifies a *VARIABLE*.

'''

[#getAllModifiesStatements]
`*STATEMENT_LIST* getAllModifiesStatements(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all STATEMENT that modifies a *VARIABLE*.

'''

[#getAllModifiesVariables]
`*VARIABLE_LIST* getAllModifiesVariables();`

*Description*: Returns a *VARIABLE_LIST* of all variables that are modified in the SIMPLE program.

'''

[#getModifiesProcedures]
`*PROCEDURE_LIST* getModifiesProcedures(*VARIABLE* var);`

*Description*: Returns a *PROCEDURE_LIST* of all *PROCEDURE* that modifies a *VARIABLE* `var`.

'''

[#getModifiesStatements]
`*STATEMENT_LIST* getModifiesStatements(*VARIABLE* var, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all *STATEMENT* of *STATEMENT_TYPE* `stmtType`, that modifies *VARIABLE* `var`.

'''

[#getModifiesVariablesFromStatement]
`*VARIABLE_LIST* getModifiesVariablesFromStatement(*INTEGER* stmt);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that `stmt` modifies.

'''

[#getModifiesVariablesFromProcedure]
`*VARIABLE_LIST* getModifiesVariablesFromProcedure(*PROCEDURE* proc);`

*Description*: Returns a *VARIABLE_LIST* of variables that were modified in `proc`.

'''

[#getAllModifiesVariablesFromStatementType]
`*VARIABLE_LIST* getModifiesVariablesFromStatementType(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a *VARIABLE_LIST* of all *VARIABLE* that is modified by any *STATEMENT* of type `stmtType`.

'''

[#getAllModifiesVariablesFromProgram]
`*VARIABLE_LIST* getAllModifiesVariablesFromProgram();`

*Description*: Returns a *VARIABLE_LIST* of all variables that were modified in any *PROCEDURE*.

'''

[#getAllModifiesStatementTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllModifiesStatementTuple(*STATEMENT_TYPE* stmtType);`

*Description*: Returns a list of all pairs where the first entry of the pair is a statement of the `stmtType`, while the second entry of the pair is a variable the statement modifies.

'''

[#getAllModifiesProcedureTuple]
`*LIST<PAIR<STATEMENT,VARIABLE>>* getAllModifiesProcedureTuple();`

*Description*: Returns a list of all pairs where the first entry of the pair is a procedure, while the second entry of the pair is a variable the procedure modifies.

=== Parent API

*Overview*: The Parent API describes the methods exposed by Parent Table to insert and extract information related to the Parent relationships in the processed SIMPLE program.

* <<addParentRelationships>>
* <<addParentRelationshipsStar>>
* <<checkIfParentHolds>>
* <<checkIfParentHoldsStar>>
* <<getAllChildStatements>>
* <<getAllChildStatementsStar>>
* <<getAllChildStatementsTyped>>
* <<getAllChildStatementsTypedStar>>
* <<getParentStatement>>
* <<getAllParentStatementsStar>>
* <<getAllParentStatementsTyped>>
* <<getAllParentStatementsTypedStar>>
* <<getAllParentTuple>>
* <<getAllParentTupleStar>>

'''

[#addParentRelationships]
`*VOID* addParentRelationships(*INTEGER* parent, *STATEMENT_TYPE*, parentType, *INTEGER* child,
*STATEMENT_TYPE* childType);`

*Requires*: `parentType` and `childType` cannot be `AnyStatement` type.

*Description*: Adds a Parent relationship between `parent` with `parentType` and `child`
with `childType` into the Parent Table.

'''

[#addParentRelationshipsStar]
`*VOID* addParentRelationshipsStar(*INTEGER* parent, *STATEMENT_TYPE* parentType,
*LIST<PAIR<STATEMENT, STATEMENT_TYPE>>* childrenStmttypePairs);`

*Requires*: `childrenStmttypePairs` cannot have statements with `AnyStatement` type.

*Description*: Adds a Parent relationship between `parent` with `parentType` and all
`childrenStmttypePairs` into the Parent Table.

'''

[#checkIfParentHolds]
`*BOOLEAN* checkIfParentHolds(*INTEGER* parent, *INTEGER* child);`

*Description*: Returns `TRUE` if there is a Parent relationship between `parent` and `child`, else return `FALSE`.

'''

[#checkIfParentHoldsStar]
`*BOOLEAN* checkIfParentHoldsStar(*INTEGER* parent, *INTEGER* child);`

*Description*: Returns `TRUE` if there is a Parent* relationship between `parent` and `child`, else return `FALSE`.

'''

[#getAllChildStatements]
`*STATEMENT_LIST* getAllChildStatements(*INTEGER* parent, *STATEMENT_TYPE* childType);`

*Description*: Returns a *STATEMENT_LIST* containing the child *STATEMENT* of `parent`, all of which are of `childType`.
*STATEMENT_LIST* returned is empty if there is no such statements exist for `parent`.

'''

[#getAllChildStatementsStar]
`*STATEMENT_LIST* getAllChildStatementsStar(*INTEGER* parent, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all _transitive_ child *STATEMENT* of `parent`.
Child *STATEMENT* are of *STATEMENT_TYPE* `stmtType`.

'''

[#getAllChildStatementsTyped]
`*STATEMENT_LIST* getAllChildStatementsTyped(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all children that are of *STATEMENT_TYPE*
`stmtTypeOfChild`, with a child of *STATEMENT_TYPE* `stmtTypeOfParent`.

'''

[#getAllChildStatementsTypedStar]
`*STATEMENT_LIST* getAllChildStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all children that are of *STATEMENT_TYPE*
`stmtTypeOfChild`, with a _transitive_ Parent of *STATEMENT_TYPE* `stmtTypeOfParent`.

'''

[#getParentStatement]
`*STATEMENT_LIST* getParentStatement(*INTEGER* child);`

*Description*: Returns a *STATEMENT_LIST* containing the parent *STATEMENT* of `child`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `child`.

'''

[#getAllParentStatementsStar]
`*STATEMENT_LIST* getAllParentStatementsStar(*INTEGER* child, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of all _transitive_ Parent of `child`.
Parents are of STATEMENT_TYPE `stmtType`.

'''

[#getAllParentStatementsTyped]
`*STATEMENT_LIST* getAllParentStatementsTyped(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all Parents that are of *STATEMENT_TYPE*
`stmtTypeOfParent`, with a child of *STATEMENT_TYPE* `stmtTypeOfChild`.

'''

[#getAllParentStatementsTypedStar]
`*STATEMENT_LIST* getAllParentStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a *STATEMENT_LIST* of all Parents that are of *STATEMENT_TYPE*
`stmtTypeOfParent`, with a _transitive_ child of *STATEMENT_TYPE* `stmtTypeOfChild`.

'''

[#getAllParentTuple]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllParentTuple(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a list of pairs, where for each pair, the *Parent* relationship holds between them, and the parent is of `stmtTypeOfParent`, and the child is of `stmtTypeOfChild`.

'''

[#getAllParentTupleStar]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllParentTupleStar(*STATEMENT_TYPE* stmtTypeOfParent,
*STATEMENT_TYPE* stmtTypeOfChild);`

*Description*: Returns a list of pairs, where for each pair, the *Parent** relationship holds between them, and the parent is of `stmtTypeOfParent`, and the child is of `stmtTypeOfChild`.

=== Follows API

*Overview*: The Follows API describes the methods exposed by Follows Table to insert and extract
information related to the Follows relationships in the processed SIMPLE program.

* <<addFollowsRelationships>>
* <<addFollowsRelationshipsStar>>
* <<checkIfFollowsHolds>>
* <<checkIfFollowsHoldsStar>>
* <<getAfterStatement>>
* <<getAllAfterStatementsStar>>
* <<getAllAfterStatementsTyped>>
* <<getAllAfterStatementsTypedStar>>
* <<getBeforeStatement>>
* <<getAllBeforeStatementsStar>>
* <<getAllBeforeStatementsTyped>>
* <<getAllBeforeStatementsTypedStar>>
* <<getAllFollowsTuple>>
* <<getAllFollowsTupleStar>>

'''

[#addFollowsRelationships]
`*VOID* addFollowsRelationships(*INTEGER* before, *STATEMENT_TYPE*, beforeStmtType, *INTEGER* after,
*STATEMENT_TYPE* afterStmtType);`

*Requires*: `beforeStmtType` and `afterStmtType` cannot be `AnyStatement` type.

*Description*: Adds a Follows relationship between `before` with `beforeStmtType` and `after`
with `afterStmtType` into the Follows Table.

'''

[#addFollowsRelationshipsStar]
`*VOID* addFollowsRelationshipsStar(*INTEGER* before, *STATEMENT_TYPE* beforeStmtType,
*LIST<PAIR<STATEMENT, STATEMENT_TYPE>>* afterStmtTypePairs);`

*Requires*: `afterStmttypePairs` cannot have statements with `AnyStatement` type.

*Description*: Adds a Follows relationship between `before` with `beforeStmtType` and all
`afterStmtTypePairs` into the Follows Table.

'''

[#checkIfFollowsHolds]
`*BOOLEAN* checkIfFollowsHolds(*INTEGER* before, *INTEGER* after);`

*Description*: Returns `TRUE` if there is a Follows relationship between `before` and `after`, else return `FALSE`.

'''

[#checkIfFollowsHoldsStar]
`*BOOLEAN* checkIfFollowsHoldsStar(*INTEGER* before, *INTEGER* after);`

*Description*: Returns `TRUE` if there is a Follows* relationship between `before` and `after`, else return `FALSE`.

'''

[#getAfterStatement]
`*STATEMENT_LIST* getAfterStatement(*INTEGER* before);`

*Description*: Returns a *STATEMENT_LIST* containing the after *STATEMENT* of `before`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `before`.

'''

[#getAllAfterStatementsStar]
`*STATEMENT_LIST* getAllAfterStatementsStar(*INTEGER* before, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of statements such that `Follows(before,returned)`
holds and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllAfterStatementsTyped]
`*STATEMENT_LIST* getAllAfterStatementsTyped(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of statements such that `Follows*(before,returned)`
holds and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllAfterStatementsTypedStar]
`*STATEMENT_LIST* getAllAfterStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all after statements that are of *STATEMENT_TYPE*
`stmtTypeOfAfter`, with a _transitive_ Follows of *STATEMENT_TYPE* `stmtTypeOfBefore`.

'''

[#getBeforeStatement]
`*STATEMENT_LIST* getBeforeStatement(*INTEGER* after);`

*Description*: Returns a *STATEMENT_LIST* containing the before *STATEMENT* of `after`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `after`.

'''

[#getAllBeforeStatementsStar]
`*STATEMENT_LIST* getAllBeforeStatementsStar(*INTEGER* after, *STATEMENT_TYPE* stmtType);`

*Description*: Returns a *STATEMENT_LIST* of statements that are before* `after` and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllBeforeStatementsTyped]
`*STATEMENT_LIST* getAllBeforeStatementsTyped(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all before statements that are of *STATEMENT_TYPE*
`stmtTypeOfBefore`, with a after of *STATEMENT_TYPE* `stmtTypeOfAfter`.

'''

[#getAllBeforeStatementsTypedStar]
`*STATEMENT_LIST* getAllBeforeStatementsTypedStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a *STATEMENT_LIST* of all before statements that are of *STATEMENT_TYPE*
`stmtTypeOfBefore`, with a _transitive_ after of *STATEMENT_TYPE* `stmtTypeOfAfter`.

'''

[#getAllFollowsTuple]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllFollowsTuple(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a list of pairs, where for each pair, the *Follows* relationship holds between them, and the before is of `stmtTypeOfBefore`, and the after is of `stmtTypeOfAfter`.

'''

[#getAllFollowsTupleStar]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllFollowsTupleStar(*STATEMENT_TYPE* stmtTypeOfBefore,
*STATEMENT_TYPE* stmtTypeOfAfter);`

*Description*: Returns a list of pairs, where for each pair, the *Follows* relationship holds between them, and the before is of `stmtTypeOfBefore`, and the after is of `stmtTypeOfAfter`.

=== Next API

*Overview*: The Next API describes the methods exposed by Next Table to insert and extract
information related to the Next relationships in the processed SIMPLE program.

* <<addNextRelationships>>
* <<checkIfNextHolds>>
* <<getAllNextStatements>>
* <<getAllNextStatementsTyped>>
* <<getAllPreviousStatements>>
* <<getAllPreviousStatementsTyped>>
* <<getAllNextTuple>>

'''

[#addNextRelationships]
`*VOID* addNextRelationships(*INTEGER* previous, *STATEMENT_TYPE*, previousStmtType, *INTEGER* next,
*STATEMENT_TYPE* nextStmtType);`

*Requires*: `previousStmtType` and `nextStmtType` cannot be `AnyStatement` type.

*Description*: Adds a Next relationship between `previous` with `previousStmtType` and `next`
with `nextStmtType` into the Next Table.

'''

[#checkIfNextHolds]
`*BOOLEAN* checkIfNextHolds(*INTEGER* previous, *INTEGER* next);`

*Description*: Returns `TRUE` if there is a Next relationship between `previous` and `next`, else return `FALSE`.

'''

[#getAllNextStatements]
`*STATEMENT_LIST* getAllNextStatements(*INTEGER* previous, *STATEMENT_TYPE* nextType);`

*Description*: Returns a *STATEMENT_LIST* containing the next *STATEMENT*s of `previous` that are of
`nextType`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `previous`.

'''

[#getAllNextStatementsTyped]
`*STATEMENT_LIST* getAllNextStatementsTyped(*STATEMENT_TYPE* stmtTypeOfPrevious,
*STATEMENT_TYPE* stmtTypeOfNext);`

*Description*: Returns a *STATEMENT_LIST* of statements such that `Next*(previous,returned)`
holds and are of STATEMENT_TYPE `stmtType`.

'''

[#getAllPreviousStatements]
`*STATEMENT_LIST* getPreviousStatement(*INTEGER* next, *STATEMENT_TYPE* previousType);`

*Description*: Returns a *STATEMENT_LIST* containing the previous *STATEMENT* of `next` that are of
`previousType`.
*STATEMENT_LIST* returned is empty if there is no such relationship for `next`.

'''

[#getAllPreviousStatementsTyped]
`*STATEMENT_LIST* getAllPreviousStatementsTyped(*STATEMENT_TYPE* stmtTypeOfPrevious,
*STATEMENT_TYPE* stmtTypeOfNext);`

*Description*: Returns a *STATEMENT_LIST* of all previous statements that are of *STATEMENT_TYPE*
`stmtTypeOfPrevious`, with a next of *STATEMENT_TYPE* `stmtTypeOfNext`.

'''

[#getAllNextTuple]
`*LIST<PAIR<STATEMENT,STATEMENT>>* getAllNextTuple(*STATEMENT_TYPE* stmtTypeOfPrevious,
*STATEMENT_TYPE* stmtTypeOfNext);`

*Description*: Returns a list of pairs, where for each pair, the *Next* relationship holds between them, and the
previous is of `stmtTypeOfPrevious`, and the next is of `stmtTypeOfNext`.

=== Calls API

*Overview*: The Calls API describes the methods exposed by Calls Table to insert and extract information related to the Calls relationships in the processed SIMPLE program.

* <<addCallsRelationships>>
* <<addCallsRelationshipsStar>>
* <<checkIfCallsHolds>>
* <<checkIfCallsHoldsStar>>
* <<getAllCallers>>
* <<getAllCallersStar>>
* <<getAllCallees>>
* <<getAllCalleesStar>>
* <<getAllCallsTuple>>
* <<getAllCallsTupleStar>>

'''

[#addCallsRelationships]
`*VOID* addCallerRelationships(*PROCEDURE* caller, *PROCEDURE* callee);`

*Description*: Adds a Calls relationship between `caller` and `callee`. This method is idempotent.

'''

[#addCallsRelationshipsStar]
`*VOID* addCallerRelationshipsStar(*PROCEDURE* caller, *PROCEDURE* callee);`

*Description*: Adds a Calls* relationship between `caller` and `callee`. This method is idempotent.

'''

[#checkIfCallsHolds]
`*BOOLEAN* checkIfCallsHolds(*PROCEDURE* caller, *PROCEDURE* callee);`

*Description*: Returns `TRUE` if there is a Calls relationship between `caller` and `callee`, else return `FALSE`.

'''

[#checkIfCallsHoldsStar]
`*BOOLEAN* checkIfCallsHoldsStar(*PROCEDURE* caller, *PROCEDURE* callee);`

*Description*: Returns `TRUE` if there is a Calls* relationship between `caller` and `callee`, else return `FALSE`.

'''

[#getAllCallers]
`*PROCEDURE_LIST* getAllCallers(*PROCEDURE* callee);`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that calls `callee` directly.
*PROCEDURE_LIST* returned is empty if there is no procedure that calls `callee` directly.

`*PROCEDURE_LIST* getAllCallers();`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that calls some process(es) directly.
*PROCEDURE_LIST* returned is empty if there is no procedure called in the program.

'''

[#getAllCallersStar]
`*PROCEDURE_LIST* getAllCallersStar(*PROCEDURE* callee);`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that calls `callee` directly or indirectly.
*PROCEDURE_LIST* returned is empty if there is no procedure that calls `callee`.

`*PROCEDURE_LIST* getAllCallersStar();`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that calls some process(es) directly or
indirectly. *PROCEDURE_LIST* returned is empty if there is no procedure called in the program.

'''

[#getAllCallees]
`*PROCEDURE_LIST* getAllCallees(*PROCEDURE* caller);`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that are called by `caller` directly.
*PROCEDURE_LIST* returned is empty if there is no procedure that are called by `caller` directly.

`*PROCEDURE_LIST* getAllCallees();`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that is called by some process(es) directly.
*PROCEDURE_LIST* returned is empty if there is no procedure called in the program.

'''

[#getAllCalleesStar]
`*PROCEDURE_LIST* getAllCalleesStar(*PROCEDURE* caller);`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that are called by `caller` directly or indirectly.
*PROCEDURE_LIST* returned is empty if there is no procedure that are called by `caller`.

`*PROCEDURE_LIST* getAllCalleesStar();`

*Description*: Returns a *PROCEDURE_LIST* containing all *PROCEDURES* that is called by some process(es) directly or
indirectly. *PROCEDURE_LIST* returned is empty if there is no procedure called in the program.

'''

[#getAllCallsTuple]
`*LIST<PAIR<PROCEDURE,PROCEDURE>>* getAllCallsTuple();`

*Description*: Returns a list of pairs of *PROCEDURE*, where for each pair, the *Calls* relationship holds
between them.

'''

[#getAllCallsTupleStar]
`*LIST<PAIR<PROCEDURE,PROCEDURE>>* getAllCallsTupleStar();`

*Description*: Returns a list of pairs of *PROCEDURE*, where for each pair, the *Calls** relationship holds
between them.

=== Utilities API

* <<resetPKB>>
* <<assignRootNode>>
* <<getRootNode>>
* <<setCFG>>
* <<getCFG>>

'''

[#resetPKB]
`*VOID* resetPKB()`

*Description*: Resets *ALL* information stored in *PKB*, as well as deleting the `RootNode` saved in
PKB from memory.This is an irreversible action.

'''

[#assignRootNode]
`*VOID* assignRootNode(*ROOT_NODE* rootNode)`

*Description*: Assigns *rootNode* to be the root node for the AST for the SIMPLE program.

'''

[#getRootNode]
`*ROOT_NODE* getRootNode()`

*Description*: Retrieves the *rootNode* stored in PKB. If <<assignRootNode>> was never called, a *NULL_POINTER* will be returned.

'''

[#setCFG]
`*VOID* storeCFG(*CFG* cfg, *PROCEDURE* proc)`

*Description*: Store `cfg` as the *CFG* for the *PROCEDURE* `proc` in PKB.

'''

[#getCFG]
`*CFG* getCFG(*PROCEDURE* proc)`

*Description*: Retrieves the *CFG* for `proc` stored in PKB.
If <<setCFG>> was never called for the `proc` given, a *NULL_POINTER* will be returned.


== PQL

=== PQLManager API
*Overview*: Handles the business logic for processing and evaluating Processed
Query Language (PQL) queries.

* <<executeQuery>>

'''

[#executeQuery]
`*FORMATTED_QUERY_RESULT* executeQuery(*STRING* query, *QUERY_RESULT_FORMAT_TYPE* format);`

*Description*: Returns a *FORMATTED_QUERY_RESULT* after processing and evaluating a
`query` in *Processed Query Language* (PQL) form. Results are formatted according to
specified `format`.

=== Preprocessor API
*Overview*: Handles the business logic for pre-processing PQL queries, including validating
syntax and semantics.

* <<processQuery>>

'''

[#processQuery]
`*ABSTRACT_QUERY* processQuery(*STRING* query);`

*Description*: Returns an *ABSTRACT_QUERY* after validating and breaking down the `query`.

=== Evaluator API
*Overview*: Evaluates the processed query and obtain a result for it by interacting
with the PKB.

* <<evaluateQuery>>

'''

[#evaluateQuery]
`*RAW_QUERY_RESULT* evaluateQuery(*ABSTRACT_QUERY* abstractQuery);`

*Description*: Returns a *RAW_QUERY_RESULT* after evaluating the `abstractQuery` and
obtaining information from the PKB.

=== Projector API
*Overview*: Formats query results into human readable context, for the Autotester and UI.

* <<formatAutotester>>
* <<formatUI>>

'''

[#formatAutotester]
`*FORMATTED_RESULT* formatAutotester(*RAW_QUERY_RESULT* rawQueryResult);`

*Description*: Returns a *FORMATTED_RESULT* after formatting `rawQueryResult` to
a conforming standard, for the Autotester.

[#formatUI]
`*FORMATTED_RESULT* formatUI(*RAW_QUERY_RESULT* rawQueryResult);`

*Description*: Returns a *FORMATTED_RESULT* after formatting `rawQueryResult` to
a conforming standard, for the UI.

== Shared Libraries (for internal use)

=== Lexer API

* <<isWhitespace>>
* <<splitByDelimiter>>
* <<splitByWhitespace>>
* <<splitProgram>>
* <<trimWhitespace>>

'''

[#isWhitespace]
`*BOOLEAN* isWhitespace(*CHAR** c);`

*Description*: Returns true if *CHAR* `c` is a whitespace character, and vice versa.

'''

[#splitByDelimiter]
`*STRING_VECTOR* splitByDelimiter(*STRING* str, *STRING* delimiter);`

*Description*: Returns a *STRING_VECTOR* of tokens after splitting
`str` by the `delimiter`.

'''

[#splitByWhitespace]
`*STRING_LIST* splitByWhitespace(*STRING* str);`

*Description*: Returns a *STRING_LIST* of tokens after splitting
`str` by whitespaces.

'''

[#splitProgram]
`*STRING_LIST* splitProgram(*STRING* program);`

*Description*: Returns a *STRING_LIST* after splitting SIMPLE program `program`
into strings containing the names, numbers, symbols that the Lexer can determine
based on SIMPLE syntax.All whitespace will be truncated from the strings.

[#trimWhitespace]
`*STRING* trimWhitespace(*STRING* str);`

*Description*: Given a string `str` that starts or ends with some whitespace
characters, or both starts and ends with whitespace characters, returns a
substring of 'str' with the starting and ending whitespaces truncated.If
the string consists only of whitespaces, return an empty string.If the
string does not contain any whitespaces (this includes the empty string),
return the same string `str`.
